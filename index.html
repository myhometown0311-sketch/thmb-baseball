<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Thumb Baseball - Stable Version</title>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
    canvas { display: block; position: absolute; top: 0; left: 0; width: 100% !important; height: 100% !important; }
    #loading {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      color: white; font-size: 20px; text-align: center; text-shadow: 2px 2px 4px #000; pointer-events: none;
      z-index: 10;
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
      border: 2px solid white;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/addons/p5.sound.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
  <div id="loading">
    ã‚·ã‚¹ãƒ†ãƒ èª­ã¿è¾¼ã¿ä¸­...<br><br>
    <span style="color: #ffff00; font-weight: bold; font-size: 24px;">ã‚¹ãƒãƒ›ã¯ã€Œæ¨ªç”»é¢ã€ã«ã—ã¦ãã ã•ã„</span><br><br>
    stadium_bg.pngã‚’é…ç½®ã—ã¦ãã ã•ã„
  </div>

<script>
// --- å¤‰æ•°å®šç¾© ---
let videoElement, hands, camera;
let thumbTip = null, indexBase = null, wrist = null;
let handDetected = false;

// ã‚²ãƒ¼ãƒ çŠ¶æ…‹ (1:Step1, 2:Step2, 3:Play, 4:Warning, 5:GameOver)
let gameState = 1;
let angleClosed = 0, angleOpen = 0, currentAngle = 0;
let currentProgressPercent = 0; 

// æ‰‹ã®ä½ç½®å›ºå®šç”¨
let fixedWristPosition = null; 
const ALLOWED_MOVEMENT_RADIUS = 100;

// ã‚²ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
let balls = [];
let panels = []; 
let score = 0;
let level = 1; 

// ãƒ©ã‚¤ãƒ•ãƒã‚¤ãƒ³ãƒˆï¼ˆ3å›ãƒŸã‚¹ã§çµ‚äº†ï¼‰
let maxLives = 3;
let lives = maxLives;

// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ç”»åƒ
let message = "", messageTimer = 0, messageColor;
let bgImage, bgLoaded = false;

// éŸ³å£°
let hitSoundOsc, hitSoundEnv; 
let audioStarted = false;

// ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆåº§æ¨™
let batRangeStart, batRangeEnd; 
let guidePositionX, guidePositionY;
let panelStartX, panelStartY;

// --- åˆæœŸåŒ–å‡¦ç† ---
function preload() {
  bgImage = loadImage('stadium_bg.png', 
    () => { bgLoaded = true; },
    () => { bgLoaded = false; console.log("èƒŒæ™¯ç”»åƒãªã—: é»’èƒŒæ™¯ã§å‹•ä½œã—ã¾ã™"); }
  );
}

function setup() {
  // â˜…é‡è¦ï¼šã‚¹ãƒãƒ›ã§ã®å‹•ä½œã‚’è»½ãã™ã‚‹è¨­å®š
  pixelDensity(1); 
  
  createCanvas(windowWidth, windowHeight);
  
  videoElement = createCapture(VIDEO);
  videoElement.size(width, height);
  videoElement.hide();

  // éŸ³å£°è¨­å®šï¼ˆåˆæœŸåŒ–ï¼‰
  hitSoundEnv = new p5.Envelope();
  hitSoundEnv.setADSR(0.001, 0.1, 0.2, 0.5); 
  hitSoundEnv.setRange(0.8, 0); 
  hitSoundOsc = new p5.Oscillator('triangle'); 
  hitSoundOsc.amp(hitSoundEnv);
  hitSoundOsc.freq(800); 

  // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã¨ãƒ‘ãƒãƒ«ã®æº–å‚™
  updateLayout();
  initPanels();

  // MediaPipe Handsã®è¨­å®š
  hands = new Hands({locateFile: (file) => 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/' + file});
  hands.setOptions({
    maxNumHands: 1, 
    modelComplexity: 1, // 0:è»½é‡, 1:æ¨™æº– (ã‚¹ãƒãƒ›ã§é‡ã„å ´åˆã¯0ã«ã™ã‚‹æ‰‹ã‚‚ã‚ã‚Š)
    minDetectionConfidence: 0.5, 
    minTrackingConfidence: 0.5
  });
  hands.onResults(onResults);

  camera = new Camera(videoElement.elt, {
    onFrame: async () => { await hands.send({image: videoElement.elt}); },
    width: 1280, height: 720
  });
  camera.start();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  updateLayout();
  // ãƒ‘ãƒãƒ«ä½ç½®ã®å†è¨ˆç®—ï¼ˆçŠ¶æ…‹ã¯ç¶­æŒï¼‰
  let oldPanels = panels;
  initPanels();
  if (oldPanels.length === panels.length) {
    for(let i=0; i<panels.length; i++) {
      panels[i].active = oldPanels[i].active;
    }
  }
}

function updateLayout() {
  batRangeStart = width * 0.85; 
  batRangeEnd = width * 0.55;   
  guidePositionX = width * 0.85;
  guidePositionY = height / 2 + 100;
}

function initPanels() {
  panels = [];
  let cols = 3; 
  let rows = 3;
  
  // ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦å°ã•ãã™ã‚‹ï¼ˆæœ€å°50%ï¼‰
  let shrinkRate = constrain(1.0 - (level - 1) * 0.1, 0.5, 1.0);
  
  let basePanelW = width * 0.06;
  let basePanelH = height * 0.10;
  
  let panelW = basePanelW * shrinkRate;
  let panelH = basePanelH * shrinkRate;
  let panelGap = 15 + (1 - shrinkRate) * 20;

  // ç”»é¢å·¦ä¸‹ã¸é…ç½®
  panelStartX = width * 0.02; 
  let totalH = rows * panelH + (rows - 1) * panelGap;
  let panelStartY = height - totalH - height * 0.05; 

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      let num = r * 3 + c + 1;
      panels.push({
        col: c, row: r, 
        x: panelStartX + c * (panelW + panelGap),
        y: panelStartY + r * (panelH + panelGap),
        w: panelW, h: panelH,
        num: num,
        active: true
      });
    }
  }
}

function onResults(results) {
  // ãƒ­ãƒ¼ãƒ‰ç”»é¢ã‚’éè¡¨ç¤º
  const loadingDiv = document.getElementById('loading');
  if (loadingDiv) loadingDiv.style.display = 'none';

  if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
    handDetected = true;
    const lm = results.multiHandLandmarks[0];
    thumbTip = createVector((1 - lm[4].x) * width, lm[4].y * height);
    indexBase = createVector((1 - lm[5].x) * width, lm[5].y * height);
    wrist = createVector((1 - lm[0].x) * width, lm[0].y * height);
    currentAngle = p5.Vector.sub(indexBase, wrist).angleBetween(p5.Vector.sub(thumbTip, wrist));
  } else {
    handDetected = false;
    thumbTip = null;
    wrist = null;
  }
}

// --- å…¥åŠ›å‡¦ç† ---
function touchStarted() { handleInput(); return false; }
function mousePressed() { handleInput(); }

function handleInput() {
  // éŸ³å£°ã‚¨ãƒ³ã‚¸ãƒ³ã®é–‹å§‹ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œãŒå¿…é ˆï¼‰
  if (!audioStarted) {
    userStartAudio();
    hitSoundOsc.start();
    audioStarted = true;
  }

  // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ or è­¦å‘Šç”»é¢ã‹ã‚‰ã®å¾©å¸°
  if (gameState === 5 || gameState === 4) { resetGame(); return; }

  // ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—é€²è¡Œ
  if (handDetected && thumbTip && wrist) {
    if (gameState === 1) { 
        angleClosed = currentAngle; 
        gameState = 2; 
    } else if (gameState === 2) { 
        angleOpen = currentAngle; 
        fixedWristPosition = createVector(wrist.x, wrist.y);
        gameState = 3; 
    }
  }
}

function resetGame() {
  gameState = 1;
  balls = [];
  score = 0;
  level = 1;
  lives = maxLives;
  fixedWristPosition = null;
  initPanels();
}

// --- æç”»ãƒ«ãƒ¼ãƒ— ---
function draw() {
  background(0); // åŸºæœ¬èƒŒæ™¯

  if (bgLoaded && bgImage) {
    // ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒã—ã¦èƒŒæ™¯æç”»
    let imgAspect = bgImage.width / bgImage.height;
    let canvasAspect = width / height;
    let dw, dh, dx, dy;
    if (canvasAspect > imgAspect) { dw=width; dh=width/imgAspect; dx=0; dy=(height-dh)/2; }
    else { dh=height; dw=height*imgAspect; dy=0; dx=(width-dw)/2; }
    image(bgImage, dx, dy, dw, dh);
  }

  // ã‚«ãƒ¡ãƒ©æ˜ åƒï¼ˆè–„ãï¼‰
  push();
  translate(width, 0); scale(-1, 1); tint(255, 120);
  image(videoElement, 0, 0, width, height);
  pop();

  // è¦ç´ æç”»
  drawPanels();
  drawAlwaysGuide();

  // ã‚²ãƒ¼ãƒ çŠ¶æ…‹åˆ†å²
  if (gameState === 3) {
    checkHandStability();
    if (gameState === 3) playGame();
  } else if (gameState === 4) {
    drawErrorScreen();
  } else if (gameState === 5) {
    drawGameOverScreen();
  } else {
    drawSetupUI();
  }
}

function drawPanels() {
  // å…¨ãƒ‘ãƒãƒ«ã‚¯ãƒªã‚¢åˆ¤å®š
  if (panels.every(p => !p.active)) {
    showMessage("PERFECT! Next Level!", color(0, 255, 255));
    if (frameCount % 60 === 0) initPanels(); 
  }

  for (let p of panels) {
    if (p.active) {
      fill(0, 255, 0, 150); 
      stroke(255); strokeWeight(3);
      rect(p.x, p.y, p.w, p.h, 5);
      
      // æ–‡å­—ã‚µã‚¤ã‚ºèª¿æ•´
      let txtSize = min(p.w, p.h) * 0.6;
      fill(255); noStroke(); textSize(txtSize); textStyle(BOLD); textAlign(CENTER, CENTER);
      text(p.num, p.x + p.w/2, p.y + p.h/2);
    } else {
      fill(50, 50); stroke(100); strokeWeight(1);
      rect(p.x, p.y, p.w, p.h, 5);
    }
  }
}

function drawAlwaysGuide() {
  noFill(); 
  let centerX = fixedWristPosition ? fixedWristPosition.x : guidePositionX;
  let centerY = fixedWristPosition ? fixedWristPosition.y : guidePositionY;

  if (handDetected) {
    stroke(0, 255, 0); // OK
    if (gameState < 3) fill(0, 255, 0, 50);
  } else {
    stroke(255, 0, 0); // NG
    noFill();
  }
  strokeWeight(4); ellipse(centerX, centerY, 100, 100);
  strokeWeight(2); rectMode(CENTER); rect(centerX, centerY - 150, 300, 400, 20);
}

function checkHandStability() {
  if (!wrist || !fixedWristPosition) return;
  if (dist(wrist.x, wrist.y, fixedWristPosition.x, fixedWristPosition.y) > ALLOWED_MOVEMENT_RADIUS) {
    gameState = 4;
  }
}

// UIé–¢é€£
function drawSetupUI() {
  textAlign(CENTER, CENTER); textSize(28); fill(255); stroke(0); strokeWeight(4);
  let uiX = guidePositionX; 
  let uiY = guidePositionY - 250;

  if (!handDetected) { 
      text("ã€é‡è¦ã€‘ã‚¹ãƒãƒ›ã¯æ¨ªç”»é¢ã«ã—ã¦ãã ã•ã„\n\næ‰‹ã‚’ã‚°ãƒ¼ã«ã—ã¦\næŒ(ã¦ã®ã²ã‚‰)å´ã‚’ã‚«ãƒ¡ãƒ©ã«å‘ã‘ã¦ãã ã•ã„", width/2, height/2); 
      return; 
  }
  
  if (gameState === 1) text("ã€STEP 1ã€‘\næ‰‹é¦–ã‚’ä¸¸ã«åˆã‚ã›\nè¦ªæŒ‡ã‚’é–‰ã˜ã¦ã‚¿ãƒƒãƒ—", uiX - 100, uiY);
  else if (gameState === 2) text("ã€STEP 2ã€‘\næ‰‹é¦–ã‚’å‹•ã‹ã•ãšã«ï¼\nè¦ªæŒ‡ã‚’å…¨é–‹ã«ã—ã¦ã‚¿ãƒƒãƒ—", uiX - 100, uiY);
}

function drawErrorScreen() {
  fill(0, 150); rect(0, 0, width, height);
  textAlign(CENTER, CENTER); textSize(40); fill(255, 50, 50); stroke(255); strokeWeight(5);
  text("æ‰‹ãŒå‹•ãã¾ã—ãŸï¼", width/2, height/2 - 50);
  textSize(24); fill(255); noStroke();
  text("æ‰‹é¦–ã®ä½ç½®ã‚’å›ºå®šã—ã¦ãã ã•ã„ã€‚\nç”»é¢ã‚¿ãƒƒãƒ—ã§ãƒªã‚»ãƒƒãƒˆ", width/2, height/2 + 50);
}

function drawGameOverScreen() {
  fill(0, 200); rect(0, 0, width, height);
  textAlign(CENTER, CENTER); 
  fill(255, 50, 50); stroke(255); strokeWeight(5); textSize(60);
  text("GAME OVER", width/2, height/2 - 50);
  fill(255); noStroke(); textSize(30);
  text(`Total Score: ${score}`, width/2, height/2 + 30);
  textSize(24);
  text("ç”»é¢ã‚¿ãƒƒãƒ—ã§ãƒªãƒˆãƒ©ã‚¤", width/2, height/2 + 100);
}

// ã‚²ãƒ¼ãƒ ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
function playGame() {
  let progress = constrain(map(currentAngle, angleClosed, angleOpen, 0, 1), 0, 1);
  currentProgressPercent = Math.round(progress * 100);

  let batX = map(progress, 0, 1, batRangeStart, batRangeEnd);
  let batY = map(progress, 0, 1, height - 100, height - 250);
  
  let isBatActive = (progress >= 0.1); 
  
  // ãƒãƒƒãƒˆã®é•·ã•ï¼ˆãƒ¬ãƒ™ãƒ«ã§çŸ­ãï¼‰
  let batBaseLen = 140;
  let batLen = max(batBaseLen - (level - 1) * 10, 50); 

  // ãƒãƒƒãƒˆæç”»
  push();
  translate(batX, batY);
  rotate(map(progress, 0, 1, PI/4, -PI/4));
  if (isBatActive) {
    fill(progress > 0.8 ? color(255,50,50) : color(255,255,0));
    stroke(0);
  } else {
    fill(100, 150);
    noStroke();
  }
  rect(-15, 0, 30, batLen, 10);
  pop();

  // ãƒœãƒ¼ãƒ«ç”Ÿæˆï¼ˆä¸€å®šé–“éš”ï¼‰
  if (balls.length === 0 && frameCount % 60 === 0) {
    balls.push(new Ball(level));
  }

  // ãƒœãƒ¼ãƒ«å‡¦ç†
  for (let i = balls.length - 1; i >= 0; i--) {
    let b = balls[i];
    b.update(); 
    b.display();
    
    // å½“ãŸã‚Šåˆ¤å®šè·é›¢ï¼ˆãƒ¬ãƒ™ãƒ«ã§å³ã—ãï¼‰
    let hitThreshold = max(250 - (level - 1) * 20, 80);

    // ãƒãƒƒãƒˆãƒ’ãƒƒãƒˆ
    if (isBatActive && !b.isHit && dist(b.x, b.y, batX, batY) < hitThreshold) {
      playHitSound();
      let hitOffset = dist(b.x, b.y, batX, batY); 
      b.hit(progress, hitOffset); 
    }

    // ãƒ‘ãƒãƒ«ãƒ’ãƒƒãƒˆ
    if (b.isHit) {
      for (let p of panels) {
        if (p.active && b.x > p.x && b.x < p.x + p.w && b.y > p.y && b.y < p.y + p.h) {
          p.active = false; 
          score++; 
          checkLevelUp();
          showMessage("ã‚¤ã‚¤ã˜ã‚ƒã‚“ï¼ğŸ‘ï¸", color(255, 200, 0));
          balls.splice(i, 1); // å½“ãŸã£ãŸã‚‰æ¶ˆãˆã‚‹
          break;
        }
      }
    }

    // ç”»é¢å¤–å‡¦ç†
    if (b.y > height + 100 || b.y < -300 || b.x < -200 || b.x > width + 200) {
      // æ‰“ãŸãšã«ç”»é¢å¤– = ãƒŸã‚¹
      if (!b.isHit) {
        lives--;
        showMessage("MISS!", color(100, 100, 255));
        if (lives <= 0) {
          gameState = 5; // Game Overã¸
        }
      }
      balls.splice(i, 1);
    }
  }

  drawGameUI(progress);
}

function checkLevelUp() {
  if (score > 0 && score % 10 === 0) {
    level++;
    showMessage(`LEVEL UP! Lv.${level}`, color(0, 255, 0));
  }
}

function playHitSound() {
  // ã‚«ã‚­ãƒ¼ãƒ³ï¼
  hitSoundOsc.freq(800);
  hitSoundEnv.play();
  setTimeout(() => {
    hitSoundOsc.freq(1200); 
  }, 30);
}

function drawGameUI(progress) {
  fill(255); stroke(0); strokeWeight(4);
  textAlign(RIGHT, TOP);
  textSize(32); 
  text(`æ‰“ç‚¹: ${score}`, width - 20, 20);
  text(`Lv.${level}`, width - 20, 60);

  // ãƒ©ã‚¤ãƒ•è¡¨ç¤º
  textAlign(LEFT, TOP);
  fill(255, 50, 50);
  let hearts = "â¤ï¸".repeat(lives);
  let empty = "ğŸ¤".repeat(maxLives - lives);
  text(`Life: ${hearts}${empty}`, 20, 20);

  // å¯å‹•åŸŸã‚²ãƒ¼ã‚¸
  let uiW = 220; let uiX = width - uiW - 20; let uiY = 100;
  
  fill(0, 150); noStroke(); rect(uiX, uiY, uiW, 80, 10);
  
  fill(255); textAlign(CENTER, TOP); textSize(16); noStroke();
  text("å¯å‹•åŸŸã‚²ãƒ¼ã‚¸", uiX + uiW/2, uiY + 5);
  
  textAlign(LEFT, TOP); textSize(12); text("é–‰", uiX + 10, uiY + 25);
  textAlign(RIGHT, TOP); text("é–‹", uiX + uiW - 10, uiY + 25);

  let barX = uiX + 10; let barY = uiY + 45; let barW = 200;
  stroke(255); strokeWeight(2); noFill(); rect(barX, barY, barW, 20);
  noStroke(); fill(progress > 0.8 ? color(255,50,50) : color(255,255,0));
  rect(barX, barY, map(progress, 0, 1, 0, barW), 20);

  if (messageTimer > 0) {
    textAlign(CENTER); fill(messageColor); stroke(0); strokeWeight(4);
    textSize(60); text(message, width/2, height/3); messageTimer--;
  }
}

function showMessage(t, c) { message = t; messageColor = c; messageTimer = 60; }

// --- ãƒœãƒ¼ãƒ«ã‚¯ãƒ©ã‚¹ ---
class Ball {
  constructor(currentLevel) {
    this.startX = 0; 
    this.startY = height * 0.85; 
    this.x = this.startX;
    this.y = this.startY;

    // ãƒãƒƒãƒˆã®å¯å‹•åŸŸã®ã©ã“ã‹ã‚’ç‹™ã†
    let targetProgress = random(0.0, 1.0); 
    let targetX = map(targetProgress, 0, 1, batRangeStart, batRangeEnd);
    let targetY = height * 0.75;

    let dirX = targetX - this.startX;
    let dirY = targetY - this.startY;
    let distLen = sqrt(dirX*dirX + dirY*dirY);
    
    // é€Ÿåº¦ï¼šåˆæœŸã¯é…ã(10ã€œ), ãƒ¬ãƒ™ãƒ«ã§é€Ÿã
    let baseSpeed = 10 + (currentLevel - 1) * 2; 
    let speed = random(baseSpeed, baseSpeed + 3); 
    
    this.vx = (dirX / distLen) * speed;
    this.vy = (dirY / distLen) * speed;

    this.isHit = false;
    this.ballColor = color(255);
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    if (this.isHit) { 
      this.vy += 0.2; // å°‘ã—é‡åŠ›
    }
  }

  display() {
    fill(this.ballColor); stroke(0); strokeWeight(1);
    ellipse(this.x, this.y, 30);
  }

  hit(progress, offset) {
    this.isHit = true;
    this.ballColor = color(255, 255, 0);

    // ãƒ‘ãƒãƒ«ã‚¨ãƒªã‚¢å…¨ä½“ã®ä½ç½®
    let areaW = 3 * panels[0].w + 30; // 3åˆ—åˆ†
    let areaLeft = panelStartX;
    let areaRight = panelStartX + areaW;

    // æ‰“ã¡åˆ†ã‘ï¼šé–‹ãå…·åˆã§å·¦å³ã‚’æ±ºå®š
    let targetX = map(progress, 0.2, 0.9, areaRight, areaLeft);

    // ä¸Šä¸‹æ‰“ã¡åˆ†ã‘ï¼šèŠ¯ã§ã®æ‰ãˆå…·åˆ
    let areaTop = panels[0].y;
    let areaBottom = panels[8].y + panels[8].h;
    let sweetSpotLimit = max(100 - (level-1)*10, 30);
    let targetY = map(offset, 0, sweetSpotLimit * 2, areaTop, areaBottom);

    let dx = targetX - this.x;
    let dy = targetY - this.y;
    let distLen = sqrt(dx*dx + dy*dy);
    
    let flySpeed = 40; 
    this.vx = (dx / distLen) * flySpeed;
    this.vy = (dy / distLen) * flySpeed;
  }
}
</script>
</body>
</html>
