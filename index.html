<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Thumb Baseball Pro - Right Batter</title>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
    canvas { display: block; position: absolute; top: 0; left: 0; width: 100% !important; height: 100% !important; }
    #loading {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      color: white; font-size: 20px; text-align: center; text-shadow: 2px 2px 4px #000; pointer-events: none;
      z-index: 10;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/addons/p5.sound.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
  <div id="loading">読み込み中...<br>stadium_bg.pngを配置してください</div>

<script>
let videoElement, hands, camera;
let thumbTip = null, indexBase = null, wrist = null;
let handDetected = false;

let gameState = 1; // 1:Step1(閉), 2:Step2(開), 3:プレイ, 4:位置ずれエラー
let angleClosed = 0, angleOpen = 0, currentAngle = 0;
let currentProgressPercent = 0; 

// 手の位置固定判定用
let fixedWristPosition = null; 
const ALLOWED_MOVEMENT_RADIUS = 100;

let balls = [];
let score = 0, combo = 0;
let message = "", messageTimer = 0, messageColor;
let bgImage, bgLoaded = false;

// バットの可動域とガイドの位置
let batRangeStart, batRangeEnd; // Start=右(閉), End=左(開)
let guidePositionX, guidePositionY;

function preload() {
  bgImage = loadImage('stadium_bg.png', 
    () => { bgLoaded = true; },
    () => { bgLoaded = false; console.log("画像なし"); }
  );
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  videoElement = createCapture(VIDEO);
  videoElement.size(width, height);
  videoElement.hide();

  // ★変更点：レイアウト設定
  // バットの開始位置（閉じた時）を画面右側、終了位置（開いた時）を画面中央寄りへ
  batRangeStart = width * 0.85; // 右側
  batRangeEnd = width * 0.55;   // 左側（スイング先）
  
  // ガイドの位置も画面右側に固定
  guidePositionX = width * 0.85;
  guidePositionY = height / 2 + 100;

  hands = new Hands({locateFile: (file) => 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/' + file});
  hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
  hands.onResults(onResults);

  camera = new Camera(videoElement.elt, {
    onFrame: async () => { await hands.send({image: videoElement.elt}); },
    width: 1280, height: 720
  });
  camera.start();
}

function onResults(results) {
  document.getElementById('loading').style.display = 'none';
  if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
    handDetected = true;
    const lm = results.multiHandLandmarks[0];
    thumbTip = createVector((1 - lm[4].x) * width, lm[4].y * height);
    indexBase = createVector((1 - lm[5].x) * width, lm[5].y * height);
    wrist = createVector((1 - lm[0].x) * width, lm[0].y * height);
    currentAngle = p5.Vector.sub(indexBase, wrist).angleBetween(p5.Vector.sub(thumbTip, wrist));
  } else {
    handDetected = false;
    thumbTip = null;
    wrist = null;
  }
}

function touchStarted() { handleInput(); return false; }
function mousePressed() { handleInput(); }

function handleInput() {
  if (getAudioContext().state !== 'running') getAudioContext().resume();
  if (gameState === 4) { resetGame(); return; }

  if (handDetected && thumbTip && wrist) {
    if (gameState === 1) { 
        angleClosed = currentAngle; 
        gameState = 2; 
    } else if (gameState === 2) { 
        angleOpen = currentAngle; 
        fixedWristPosition = createVector(wrist.x, wrist.y);
        gameState = 3; 
    }
  }
}

function resetGame() {
  gameState = 1;
  balls = [];
  score = 0;
  combo = 0;
  fixedWristPosition = null;
}

function draw() {
  if (bgLoaded && bgImage) {
    let imgAspect = bgImage.width / bgImage.height;
    let canvasAspect = width / height;
    let dw, dh, dx, dy;
    if (canvasAspect > imgAspect) { dw=width; dh=width/imgAspect; dx=0; dy=(height-dh)/2; }
    else { dh=height; dw=height*imgAspect; dy=0; dx=(width-dw)/2; }
    image(bgImage, dx, dy, dw, dh);
  } else {
    background(0);
  }

  // カメラ映像（薄く）
  push();
  translate(width, 0); scale(-1, 1); tint(255, 120);
  image(videoElement, 0, 0, width, height);
  pop();

  drawAlwaysGuide();

  if (gameState === 3) {
    checkHandStability();
    if (gameState === 3) playGame();
  } else if (gameState === 4) {
    drawErrorScreen();
  } else {
    drawSetupUI();
  }
}

function drawAlwaysGuide() {
  noFill(); 
  // ★変更点：ガイドの位置を右側に固定
  let centerX = fixedWristPosition ? fixedWristPosition.x : guidePositionX;
  let centerY = fixedWristPosition ? fixedWristPosition.y : guidePositionY;

  if (handDetected) {
    stroke(0, 255, 0); // OK(緑)
    if (gameState < 3) fill(0, 255, 0, 50);
  } else {
    stroke(255, 0, 0); // NG(赤)
    noFill();
  }
  strokeWeight(4); ellipse(centerX, centerY, 100, 100);
  strokeWeight(2); rectMode(CENTER); rect(centerX, centerY - 150, 300, 400, 20);
}

function checkHandStability() {
  if (!wrist || !fixedWristPosition) return;
  if (dist(wrist.x, wrist.y, fixedWristPosition.x, fixedWristPosition.y) > ALLOWED_MOVEMENT_RADIUS) {
    gameState = 4;
  }
}

function drawSetupUI() {
  textAlign(CENTER, CENTER); textSize(28); fill(255); stroke(0); strokeWeight(4);
  
  // ガイドの近くに文字を表示
  let uiX = guidePositionX; 
  let uiY = guidePositionY - 250;

  if (!handDetected) { text("右側の枠が「緑」になるように\n手を映してください", width/2, height/2); return; }
  
  if (gameState === 1) text("【STEP 1】\n手首を右の丸に合わせ\n親指を閉じてタップ", uiX - 100, uiY);
  else if (gameState === 2) text("【STEP 2】\n手首を動かさずに！\n親指を全開にしてタップ", uiX - 100, uiY);
}

function drawErrorScreen() {
  fill(0, 150); rect(0, 0, width, height);
  textAlign(CENTER, CENTER); textSize(40); fill(255, 50, 50); stroke(255); strokeWeight(5);
  text("手が動きました！", width/2, height/2 - 50);
  textSize(24); fill(255); noStroke();
  text("手首の位置を固定してください。\n画面タップでリセット", width/2, height/2 + 50);
}

function playGame() {
  let progress = constrain(map(currentAngle, angleClosed, angleOpen, 0, 1), 0, 1);
  currentProgressPercent = Math.round(progress * 100);

  // ★変更点：バットは右(閉)から左(開)へ振る
  let batX = map(progress, 0, 1, batRangeStart, batRangeEnd);
  let batY = map(progress, 0, 1, height - 100, height - 250);

  let isBatActive = (progress >= 0.15); // 少し開かないと打てない

  push();
  translate(batX, batY);
  // 角度も右傾きから左傾きへ
  rotate(map(progress, 0, 1, PI/4, -PI/4));
  
  if (isBatActive) {
    fill(progress > 0.8 ? color(255,50,50) : color(255,255,0));
    stroke(0);
  } else {
    fill(100, 150);
    noStroke();
  }
  rect(-15, 0, 30, 140, 10);
  
  if (!isBatActive) {
    fill(255); noStroke(); textSize(16); textAlign(CENTER);
    text("待機", 0, -20);
  }
  pop();

  if (balls.length === 0 && frameCount % 60 === 0) {
    balls.push(new Ball());
  }

  for (let i = balls.length - 1; i >= 0; i--) {
    let b = balls[i];
    b.update(); b.display();
    
    if (isBatActive && !b.isHit && dist(b.x, b.y, batX, batY) < 70) {
      let pct = progress * 100;
      if (pct <= 20) { b.hit("foul"); showMessage("Foul", color(200)); combo=0; }
      else if (pct <= 85) { b.hit("hit"); score++; combo++; }
      else { b.hit("homerun"); score+=5; combo++; showMessage("Home Run!", color(255,50,50)); }
    }
    if (b.y > height + 100 || b.x < -200 || b.x > width + 200) balls.splice(i, 1);
  }

  drawGameUI();
}

function drawGameUI() {
  fill(255); stroke(0); strokeWeight(4);
  // スコア表示は左上
  textSize(32); textAlign(LEFT, TOP);
  text(`Score: ${score}`, 20, 20);

  // 開閉率は右上に（バッターの近く）
  textAlign(RIGHT, TOP);
  text(`開閉: ${currentProgressPercent}%`, width - 20, 20);
  
  if (messageTimer > 0) {
    textAlign(CENTER); fill(messageColor); stroke(0); strokeWeight(4);
    textSize(60); text(message, width/2, height/3); messageTimer--;
  }
}

function showMessage(t, c) { message = t; messageColor = c; messageTimer = 60; }

class Ball {
  constructor() {
    // ★変更点：ピッチャーは左上から投げる
    this.startX = width * 0.15; // 左側
    this.startY = -30;
    this.x = this.startX;
    this.y = this.startY;

    // ★変更点：ターゲットは右側のバット可動域
    // 親指を開いたあたり(batRangeEnd)を狙う
    let targetProgress = random(0.2, 1.0); 
    // 右側の打撃ゾーンをターゲットにする
    let targetX = map(targetProgress, 0, 1, batRangeStart, batRangeEnd);
    let targetY = height * 0.75;

    let dirX = targetX - this.startX;
    let dirY = targetY - this.startY;
    let len = sqrt(dirX*dirX + dirY*dirY);
    let speed = random(9, 13); // 少し速めに調整
    
    this.vx = (dirX / len) * speed;
    this.vy = (dirY / len) * speed;

    this.isHit = false;
    this.ballColor = color(255);
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    if (this.isHit) { this.vy += 0.8; this.vx *= 0.98; }
  }

  display() {
    fill(this.ballColor); stroke(0); strokeWeight(1);
    ellipse(this.x, this.y, 30);
  }

  hit(type) {
    this.isHit = true;
    // 打ったら左上（センター方向）へ飛び返す演出
    if (type === "foul") { this.vy = -5; this.vx = 2; this.ballColor = color(150); }
    else if (type === "hit") { this.vy = -15; this.vx = random(-5, -15); this.ballColor = color(255,255,0); }
    else { this.vy = -30; this.vx = random(-10, -25); this.ballColor = color(255,50,50); }
  }
}
</script>
</body>
</html>
