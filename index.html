<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Thumb Baseball Pro - Precision Mode Fixed</title>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
    canvas { display: block; position: absolute; top: 0; left: 0; width: 100% !important; height: 100% !important; }
    #loading {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      color: white; font-size: 20px; text-align: center; text-shadow: 2px 2px 4px #000; pointer-events: none;
      z-index: 10;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/addons/p5.sound.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
  <div id="loading">読み込み中...<br>stadium_bg.pngを配置してください</div>

<script>
let videoElement, hands, camera;
let thumbTip = null, indexBase = null, wrist = null;
let handDetected = false; // 手が認識されているかどうかのフラグ

let gameState = 1; // 1:Step1(閉), 2:Step2(開), 3:プレイ, 4:位置ずれエラー
let angleClosed = 0, angleOpen = 0, currentAngle = 0;
let currentProgressPercent = 0; 

// 手の位置固定判定用
let fixedWristPosition = null; 
const ALLOWED_MOVEMENT_RADIUS = 100; // 手が動いていい範囲（少し広げました）

let balls = [];
let score = 0, combo = 0;
let message = "", messageTimer = 0, messageColor;
let bgImage, bgLoaded = false;
let batRangeMin, batRangeMax;

function preload() {
  bgImage = loadImage('stadium_bg.png', 
    () => { bgLoaded = true; },
    () => { bgLoaded = false; console.log("画像なし"); }
  );
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  videoElement = createCapture(VIDEO);
  videoElement.size(width, height);
  videoElement.hide();

  batRangeMin = width / 2 - 150;
  batRangeMax = width / 2 + 150;

  hands = new Hands({locateFile: (file) => 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/' + file});
  hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
  hands.onResults(onResults);

  camera = new Camera(videoElement.elt, {
    onFrame: async () => { await hands.send({image: videoElement.elt}); },
    width: 1280, height: 720
  });
  camera.start();
}

function onResults(results) {
  document.getElementById('loading').style.display = 'none';
  
  if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
    handDetected = true;
    const lm = results.multiHandLandmarks[0];
    thumbTip = createVector((1 - lm[4].x) * width, lm[4].y * height);
    indexBase = createVector((1 - lm[5].x) * width, lm[5].y * height);
    wrist = createVector((1 - lm[0].x) * width, lm[0].y * height);
    
    currentAngle = p5.Vector.sub(indexBase, wrist).angleBetween(p5.Vector.sub(thumbTip, wrist));
  } else {
    handDetected = false;
    thumbTip = null;
    wrist = null;
  }
}

// スマホ・PC両対応の入力処理
function touchStarted() { handleInput(); return false; }
function mousePressed() { handleInput(); }

function handleInput() {
  if (getAudioContext().state !== 'running') getAudioContext().resume();

  // エラー画面からの復帰
  if (gameState === 4) {
    resetGame();
    return;
  }

  // 手が認識されているときだけ進行
  if (handDetected && thumbTip && wrist) {
    if (gameState === 1) { 
        angleClosed = currentAngle; 
        gameState = 2; 
        console.log("Step 1 OK");
    } else if (gameState === 2) { 
        angleOpen = currentAngle; 
        // ここで手首の位置を固定
        fixedWristPosition = createVector(wrist.x, wrist.y);
        gameState = 3; 
        console.log("Step 2 OK, Game Start");
    }
  }
}

function resetGame() {
  gameState = 1;
  balls = [];
  score = 0;
  combo = 0;
  fixedWristPosition = null;
}

function draw() {
  // 背景
  if (bgLoaded && bgImage) {
    let imgAspect = bgImage.width / bgImage.height;
    let canvasAspect = width / height;
    let dw, dh, dx, dy;
    if (canvasAspect > imgAspect) { dw=width; dh=width/imgAspect; dx=0; dy=(height-dh)/2; }
    else { dh=height; dw=height*imgAspect; dy=0; dx=(width-dw)/2; }
    image(bgImage, dx, dy, dw, dh);
  } else {
    background(0);
  }

  // カメラ映像（薄く）
  push();
  translate(width, 0); scale(-1, 1); tint(255, 120);
  image(videoElement, 0, 0, width, height);
  pop();

  // 常に表示するガイド
  drawAlwaysGuide();

  if (gameState === 3) {
    checkHandStability(); // 手ブレチェック
    if (gameState === 3) playGame();
  } else if (gameState === 4) {
    drawErrorScreen();
  } else {
    drawSetupUI();
  }
}

// 手首固定ガイド（認識中は緑色になる！）
function drawAlwaysGuide() {
  noFill(); 
  let centerX = fixedWristPosition ? fixedWristPosition.x : width/2;
  let centerY = fixedWristPosition ? fixedWristPosition.y : height/2 + 100;

  // 手が認識されているなら「緑」、されていないなら「赤」
  if (handDetected) {
    stroke(0, 255, 0); // 緑 (OK)
    if (gameState < 3) fill(0, 255, 0, 50); // 設定中は少し色をつける
  } else {
    stroke(255, 0, 0); // 赤 (NG)
    noFill();
  }
  
  strokeWeight(4);
  ellipse(centerX, centerY, 100, 100); // 手首サークル
  
  strokeWeight(2);
  rectMode(CENTER);
  rect(centerX, centerY - 150, 300, 400, 20); // グーの枠
}

function checkHandStability() {
  if (!wrist || !fixedWristPosition) return;
  // 記憶した位置からの距離
  let d = dist(wrist.x, wrist.y, fixedWristPosition.x, fixedWristPosition.y);
  if (d > ALLOWED_MOVEMENT_RADIUS) {
    gameState = 4; // 手が動きすぎたらエラー
  }
}

function drawSetupUI() {
  textAlign(CENTER, CENTER); textSize(28); fill(255); stroke(0); strokeWeight(4);
  
  if (!handDetected) { 
      text("枠が「緑」になるように\n手を映してください", width/2, height/2 - 50); return; 
  }

  if (gameState === 1) {
    fill(255);
    text("【STEP 1】\n手首を丸に合わせ\n親指を閉じてタップ", width/2, height/2 - 100);
  } else if (gameState === 2) {
    fill(100, 255, 255);
    text("【STEP 2】\n手首を動かさずに！\n親指を全開にしてタップ", width/2, height/2 - 100);
  }
}

function drawErrorScreen() {
  fill(0, 150); rect(0, 0, width, height);
  textAlign(CENTER, CENTER); textSize(40); fill(255, 50, 50); stroke(255); strokeWeight(5);
  text("手が動きました！", width/2, height/2 - 50);
  textSize(24); fill(255); noStroke();
  text("手首の位置を固定してください。\n画面タップでリセット", width/2, height/2 + 50);
}

function playGame() {
  let progress = constrain(map(currentAngle, angleClosed, angleOpen, 0, 1), 0, 1);
  currentProgressPercent = Math.round(progress * 100);

  let batX = map(progress, 0, 1, batRangeMin, batRangeMax);
  let batY = map(progress, 0, 1, height - 100, height - 250);

  // バット
  push();
  translate(batX, batY);
  rotate(map(progress, 0, 1, -PI/6, PI/6));
  fill(progress > 0.8 ? color(255,50,50) : (progress > 0.2 ? color(255,255,0) : color(200)));
  rect(-15, 0, 30, 140, 10);
  pop();

  // ボール1個制限 & 間隔調整
  if (balls.length === 0 && frameCount % 60 === 0) {
    balls.push(new Ball());
  }

  for (let i = balls.length - 1; i >= 0; i--) {
    let b = balls[i];
    b.update(); b.display();
    
    // 当たり判定
    if (!b.isHit && dist(b.x, b.y, batX, batY) < 70) {
      let pct = progress * 100;
      if (pct <= 15) { b.hit("foul"); showMessage("Foul", color(200)); combo=0; }
      else if (pct <= 85) { b.hit("hit"); score++; combo++; }
      else { b.hit("homerun"); score+=5; combo++; showMessage("Home Run!", color(255,50,50)); }
    }
    // 画面外削除
    if (b.y > height + 100 || b.x < -200 || b.x > width + 200) balls.splice(i, 1);
  }

  drawGameUI();
}

function drawGameUI() {
  fill(255); stroke(0); strokeWeight(4);
  textSize(32); textAlign(LEFT, TOP);
  text(`Score: ${score}`, 20, 20);
  textAlign(RIGHT, TOP);
  text(`開閉: ${currentProgressPercent}%`, width - 20, 20);
  
  if (messageTimer > 0) {
    textAlign(CENTER); fill(messageColor); stroke(0); strokeWeight(4);
    textSize(60); text(message, width/2, height/3); messageTimer--;
  }
}

function showMessage(t, c) { message = t; messageColor = c; messageTimer = 60; }

class Ball {
  constructor() {
    this.startX = width / 2;
    this.startY = -30;
    this.x = this.startX;
    this.y = this.startY;

    // バットの可動域内を狙う
    let targetProgress = random(0.1, 0.9); 
    let targetX = map(targetProgress, 0, 1, batRangeMin, batRangeMax);
    let targetY = height * 0.75;

    let dirX = targetX - this.startX;
    let dirY = targetY - this.startY;
    let len = sqrt(dirX*dirX + dirY*dirY);
    
    let speed = random(8, 12);
    this.vx = (dirX / len) * speed;
    this.vy = (dirY / len) * speed;

    this.isHit = false;
    this.ballColor = color(255);
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    if (this.isHit) { this.vy += 0.8; this.vx *= 0.98; }
  }

  display() {
    fill(this.ballColor); stroke(0); strokeWeight(1);
    ellipse(this.x, this.y, 30);
  }

  hit(type) {
    this.isHit = true;
    if (type === "foul") { this.vy = -5; this.ballColor = color(150); }
    else if (type === "hit") { this.vy = -15; this.vx = random(-10, 10); this.ballColor = color(255,255,0); }
    else { this.vy = -30; this.vx = random(-20, 20); this.ballColor = color(255,50,50); }
  }
}
</script>
</body>
</html>

