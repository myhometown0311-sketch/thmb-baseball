<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Thumb Rehab Fix</title>
<style>
  /* --- 基本スタイル --- */
  body {
    margin: 0; padding: 0; overflow: hidden;
    background-color: #222; font-family: sans-serif;
    touch-action: none; color: white;
  }

  /* キャンバス（ゲーム描画用） */
  canvas {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 5;
  }

  /* 修正ポイント：ビデオを「消す」のではなく「透明にして裏に置く」 */
  /* iPhoneは display:none のビデオを再生しないため */
  #input_video {
    position: fixed; top: 0; left: 0; width: 1px; height: 1px;
    opacity: 0; z-index: -1; pointer-events: none;
  }

  /* UIレイヤー（最前面） */
  #ui-layer {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 100;
    pointer-events: none; 
    display: flex; flex-direction: column; align-items: center; justify-content: center;
  }

  .screen {
    position: absolute; width: 90%; max-width: 400px;
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid #555; border-radius: 12px;
    padding: 20px; text-align: center;
    pointer-events: auto; 
    display: none;
  }
  .screen.active { display: block; }

  h1 { color: #ffcc00; margin-bottom: 10px; font-size: 22px; }
  h2 { color: #4db8ff; margin-bottom: 15px; font-size: 18px; }
  p { font-size: 14px; color: #ccc; margin-bottom: 20px; }

  .btn {
    display: block; width: 100%; margin: 10px 0; padding: 15px;
    font-size: 18px; font-weight: bold; color: #000;
    background: #ffeb3b; border: none; border-radius: 30px; cursor: pointer;
  }
  .btn:active { background: #fbc02d; transform: scale(0.98); }

  /* デバッグログ（画面下に小さく表示） */
  #debug-log {
    position: fixed; bottom: 0; left: 0; width: 100%;
    background: rgba(0,0,0,0.5); color: lime;
    font-size: 10px; font-family: monospace;
    padding: 5px; pointer-events: none; z-index: 200;
  }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

<div id="debug-log">System Ready...</div>

<div id="ui-layer">
  <div id="screen-menu" class="screen active">
    <h1>Thumb Rehab</h1>
    <p>親指リハビリ・ストラックアウト</p>
    <button class="btn" onclick="startApp('right')">右手でスタート</button>
    <button class="btn" onclick="startApp('left')">左手でスタート</button>
  </div>

  <div id="screen-loading" class="screen">
    <h2>カメラ起動中...</h2>
    <p>許可ポップアップが出たら<br>「許可」を押してください。</p>
    <div style="font-size:12px; color:#aaa;">※画面が黒い場合は再読み込みしてください</div>
  </div>

  <div id="screen-calib" class="screen">
    <h2 id="calib-title">測定：閉じる</h2>
    <p id="calib-desc">親指を閉じて（グー）<br>ボタンを押してください</p>
    <div style="font-size:30px; margin:15px; color:#4db8ff;" id="calib-val">0 mm</div>
    <button class="btn" onclick="nextStep()">記録する</button>
  </div>

  <div id="screen-result" class="screen">
    <h1 style="color:#ff5555;">終了</h1>
    <p id="final-score">Score: 0</p>
    <button class="btn" onclick="location.reload()">もう一度</button>
  </div>
</div>

<div style="position:fixed; top:10px; left:10px; font-size:20px; z-index:50; color:white; display:none;" id="hud-lives">❤️❤️❤️</div>

<video id="input_video" playsinline webkit-playsinline muted autoplay></video>

<script>
// --- 変数 ---
let videoElement = document.getElementById('input_video');
let hands;
let isRightHand = true;
let appState = 0; // 0:Menu, 1:Load, 2:Calib, 3:Game, 4:Result

let landmarks = null;
let handScale = 100; 
let thumbDistMm = 0;
let distClose = 0; let distOpen = 0;

let balls = []; let panels = [];
let score = 0; let lives = 3;
let batSwing = 0;
let frameCountVal = 0;

// --- ログ表示 ---
function log(msg) {
  document.getElementById('debug-log').innerText = msg;
  console.log(msg);
}

// --- 開始フロー ---
async function startApp(hand) {
  isRightHand = (hand === 'right');
  switchScreen('screen-loading');
  log("Requesting Camera...");

  try {
    // カメラ取得
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: false,
      video: { 
        facingMode: 'user', 
        width: { ideal: 640 }, 
        height: { ideal: 480 } 
      }
    });
    
    videoElement.srcObject = stream;
    // スマホ用: 明示的に再生
    await videoElement.play();
    log("Camera Started. Loading AI...");

    // MediaPipe初期化
    hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 0, // Lite
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    // AIループ開始
    loopAI();

  } catch(e) {
    log("Error: " + e.name + " / " + e.message);
    alert("カメラエラー:\n" + e.name + "\nhttpsで開いていますか？");
    switchScreen('screen-menu');
  }
}

async function loopAI() {
  if (videoElement.readyState >= 2) {
    await hands.send({image: videoElement});
    // AIが動いたら画面遷移（初回のみ）
    if(appState === 0 || document.getElementById('screen-loading').classList.contains('active')) {
      log("AI Ready. To Calibration.");
      setupCalibClose();
    }
  }
  requestAnimationFrame(loopAI);
}

function onResults(results) {
  if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
    landmarks = results.multiHandLandmarks[0];
    calcHand();
  } else {
    landmarks = null;
  }
}

function calcHand() {
  if(!landmarks) return;
  // 簡易計算: 手首(0)〜人差指付根(5)を10cmと仮定
  // 親指先(4)〜人差指付根(5)の距離を計測
  let w = width; let h = height;
  let p0 = {x:(1-landmarks[0].x)*w, y:landmarks[0].y*h};
  let p5 = {x:(1-landmarks[5].x)*w, y:landmarks[5].y*h};
  let p4 = {x:(1-landmarks[4].x)*w, y:landmarks[4].y*h};

  let pxBase = dist(p0.x, p0.y, p5.x, p5.y);
  let mmPerPx = 100 / pxBase;
  let pxThumb = dist(p4.x, p4.y, p5.x, p5.y);
  
  thumbDistMm = Math.floor(pxThumb * mmPerPx);

  // UI反映
  if(appState === 2) {
    document.getElementById('calib-val').innerText = thumbDistMm + " mm";
  }
}

// --- キャリブレーション手順 ---
function setupCalibClose() {
  appState = 2;
  switchScreen('screen-calib');
  // 状態初期化
  distClose = 0; distOpen = 0;
  updateCalibUI("測定：閉じる", "親指を閉じて（グー）<br>ボタンを押してください", "記録する");
}

function updateCalibUI(title, desc, btn) {
  document.getElementById('calib-title').innerText = title;
  document.getElementById('calib-desc').innerHTML = desc;
  document.querySelector('#screen-calib .btn').innerText = btn;
}

function nextStep() {
  const btn = document.querySelector('#screen-calib .btn');
  const title = document.getElementById('calib-title');

  if(title.innerText.includes("閉じる")) {
    // 閉じた値を記録 -> 次へ
    distClose = thumbDistMm;
    updateCalibUI("測定：開く", "親指を最大まで開いて<br>ボタンを押してください", "ゲーム開始");
  } else {
    // 開いた値を記録 -> ゲームへ
    distOpen = thumbDistMm;
    if(distOpen <= distClose + 5) {
      alert("動きが小さすぎます。もう一度測定します。");
      setupCalibClose();
      return;
    }
    startGame();
  }
}

// --- ゲーム本体 ---
function startGame() {
  appState = 3;
  switchScreen(null); // 全画面消去
  document.getElementById('hud-lives').style.display = 'block';
  score = 0; lives = 3; balls = []; panels = [];
  updateLives();

  // パネル生成
  let pw = width*0.12; let ph = height*0.08;
  let ox = isRightHand ? width*0.1 : width*0.55;
  for(let r=0; r<3; r++){
    for(let c=0; c<3; c++){
      // 上段(r2)〜下段(r0)
      let id = (r*3)+c+1;
      let y = height*0.7 - (r*(ph+10));
      let x = ox + c*(pw+5);
      panels.push({id:id, x:x, y:y, w:pw, h:ph, active:true});
    }
  }
  log("Game Started!");
}

function setup() {
  createCanvas(windowWidth, windowHeight);
}

function draw() {
  clear(); // 透明

  // 1. 映像描画 (Canvasへ)
  if(videoElement.readyState >= 2) {
    push();
    translate(width, 0); scale(-1, 1);
    let vw = videoElement.videoWidth; let vh = videoElement.videoHeight;
    let s = max(width/vw, height/vh);
    let w = vw*s; let h = vh*s;
    image(videoElement, (width-w)/2, (height-h)/2, w, h);
    fill(0,100); noStroke(); rect(0,0,width,height); // 暗幕
    pop();
  }

  // 2. ゲーム描画
  if(appState === 3) {
    runGame();
  }

  // 3. 骨格ガイド
  if(landmarks) drawSkeleton();
}

function drawSkeleton() {
  let w = width; let h = height;
  let p5 = {x:(1-landmarks[5].x)*w, y:landmarks[5].y*h};
  let p4 = {x:(1-landmarks[4].x)*w, y:landmarks[4].y*h};
  
  stroke(0,255,255); strokeWeight(3);
  line(p5.x, p5.y, p4.x, p4.y);
  fill(255,0,0); noStroke(); circle(p4.x, p4.y, 15);
}

function runGame() {
  frameCountVal++;
  
  // スイング計算
  let ratio = map(thumbDistMm, distClose, distOpen, 0, 1);
  batSwing = constrain(ratio, 0, 1);
  
  // ガイドバー
  drawGauge();

  // ボール生成
  if(frameCountVal % 100 === 0) spawnBall();
  
  // ボール処理
  updateBalls();
  
  // パネル
  drawPanels();
}

function drawGauge() {
  // 右端or左端にゲージ
  let x = isRightHand ? width-20 : 20;
  let h = 200;
  let y = height/2;
  
  fill(100); rect(x-5, y-h/2, 10, h);
  let barY = map(batSwing, 0, 1, y+h/2, y-h/2);
  fill(0,255,0); circle(x, barY, 20);
  
  // 区切り
  stroke(255);
  line(x-10, y-h/6, x+10, y-h/6);
  line(x-10, y+h/6, x+10, y+h/6);
}

function spawnBall() {
  let sx = isRightHand ? 0 : width;
  let tx = isRightHand ? width*0.8 : width*0.2;
  balls.push({x:sx, y:height*0.6, vx:(tx-sx)/50, vy:0, active:true, hit:false});
}

function updateBalls() {
  let hitX = isRightHand ? width*0.8 : width*0.2;

  for(let i=balls.length-1; i>=0; i--){
    let b = balls[i];
    b.x += b.vx; b.y += b.vy;
    
    fill(255); noStroke(); circle(b.x, b.y, 20);

    // ヒット判定
    if(!b.hit && b.active && abs(b.x - hitX) < 40 && batSwing > 0.2) {
      b.hit = true;
      // 狙い (0:下, 1:中, 2:上)
      let aim = 0;
      if(batSwing > 0.66) aim = 2;
      else if(batSwing > 0.33) aim = 1;
      
      // 適当なパネルへ
      let row = aim; let col = floor(random(3));
      let pid = (row*3)+col+1;
      let p = panels.find(pa => pa.id == pid);
      let tx = p ? p.x+p.w/2 : (isRightHand?0:width);
      let ty = p ? p.y+p.h/2 : 0;
      let dx = tx-b.x; let dy = ty-b.y;
      let d = sqrt(dx*dx+dy*dy);
      b.vx = (dx/d)*20; b.vy = (dy/d)*20;
    }
    
    // パネル破壊
    if(b.hit && b.active) {
      for(let p of panels) {
        if(p.active && b.x>p.x && b.x<p.x+p.w && b.y>p.y && b.y<p.y+p.h) {
          p.active = false; b.active = false; score+=100; updateLives(); break;
        }
      }
    }
    
    // 画面外
    if(b.x<-50 || b.x>width+50 || b.y<-50 || b.y>height+50) {
      if(!b.hit && b.active) {
        lives--; updateLives();
        if(lives<=0) { appState=4; document.getElementById('final-score').innerText="Score: "+score; switchScreen('screen-result'); }
      }
      balls.splice(i,1);
    }
  }
}

function drawPanels() {
  let allClear = true;
  for(let p of panels) {
    if(p.active) {
      allClear = false;
      fill(0,200,0,150); stroke(255); rect(p.x, p.y, p.w, p.h);
      fill(255); noStroke(); textAlign(CENTER,CENTER); textSize(20);
      text(p.id, p.x+p.w/2, p.y+p.h/2);
    }
  }
  if(allClear && panels.length > 0) {
    score+=1000; startGame(); // ループ
  }
}

function updateLives() {
  let s = ""; for(let i=0;i<lives;i++) s+="❤️";
  document.getElementById('hud-lives').innerHTML = s + " " + score;
}

function switchScreen(id) {
  document.querySelectorAll('.screen').forEach(e=>e.classList.remove('active'));
  if(id) document.getElementById(id).classList.add('active');
}

function windowResized() { resizeCanvas(windowWidth, windowHeight); }
</script>
</body>
</html>

