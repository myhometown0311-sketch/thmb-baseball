<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Thumb Rehab Universal</title>
<style>
  body {
    margin: 0; padding: 0; overflow: hidden;
    background-color: #111; font-family: sans-serif;
    color: white; touch-action: none;
  }
  
  /* ゲーム画面（キャンバス） */
  canvas {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 1;
  }

  /* HTMLビデオ要素（裏で動かす用：非表示だが存在させる） */
  #raw-video {
    position: absolute; top: 0; left: 0; width: 1px; height: 1px;
    opacity: 0; pointer-events: none; z-index: -10;
  }

  /* UIレイヤー */
  #ui-layer {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 100; pointer-events: none;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
  }

  /* パネル */
  .screen {
    position: relative; width: 90%; max-width: 450px;
    background: rgba(20,20,20,0.9);
    border: 2px solid #666; border-radius: 12px;
    padding: 25px; text-align: center;
    pointer-events: auto; display: none;
    box-shadow: 0 10px 40px rgba(0,0,0,0.8);
  }
  .screen.active { display: block; }

  h1 { color: #ffeb3b; margin: 0 0 10px 0; }
  p { color: #ccc; margin-bottom: 20px; font-size: 14px; line-height: 1.5; }

  .btn {
    width: 100%; padding: 15px; font-size: 18px; font-weight: bold;
    background: #ffeb3b; border: none; border-radius: 8px;
    cursor: pointer; margin-top: 10px; color: #000;
  }
  .btn:hover { background: #fdd835; }

  /* エラー表示エリア（最重要） */
  #error-box {
    position: fixed; top: 0; left: 0; width: 100%;
    background: #d32f2f; color: white; padding: 10px;
    font-size: 12px; font-family: monospace; z-index: 9999;
    display: none; text-align: center;
  }
  
  /* HUD */
  #hud {
    position: fixed; top: 10px; left: 10px; z-index: 50;
    font-size: 20px; display: none; text-shadow: 1px 1px 2px black;
  }
  #rom-val {
    position: fixed; top: 10px; right: 10px; z-index: 50;
    font-size: 16px; background: rgba(0,0,0,0.5); padding: 5px;
    border: 1px solid cyan; color: cyan; display: none;
  }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

<div id="error-box"></div>

<video id="raw-video" playsinline webkit-playsinline muted></video>

<div id="hud">❤️❤️❤️</div>
<div id="rom-val">ROM: 0mm</div>

<div id="ui-layer">
  
  <div id="screen-menu" class="screen active">
    <h1>Thumb Rehab</h1>
    <p>PC/スマホ対応 親指リハビリ<br>
    <small>※https接続が必須です</small></p>
    <button class="btn" onclick="systemCheck('right')">右手で開始</button>
    <button class="btn" onclick="systemCheck('left')">左手で開始</button>
  </div>

  <div id="screen-calib" class="screen">
    <h2 id="calib-title" style="color:cyan;">測定：閉じる</h2>
    <p id="calib-msg">親指を閉じて（グー）<br>ボタンを押してください</p>
    <div id="calib-display" style="font-size:30px; color:cyan; margin:15px;">0 mm</div>
    <button class="btn" onclick="nextCalib()">記録する</button>
  </div>

  <div id="screen-result" class="screen">
    <h1 style="color:#ff5252;">終了</h1>
    <p id="score-result">Score: 0</p>
    <button class="btn" onclick="location.reload()">タイトルへ</button>
  </div>

</div>

<script>
// --- グローバル変数 ---
const videoElem = document.getElementById('raw-video');
let hands;
let isRightHand = true;
let appState = 0; // 0:Menu, 1:Calib, 2:Game, 3:Result

// 診断用
let isCameraReady = false;

// MediaPipeデータ
let landmarks = null;
let thumbDistMm = 0;

// キャリブレーション
let distClose = 0; 
let distOpen = 0;

// ゲームデータ
let balls = [];
let panels = [];
let score = 0;
let lives = 3;
let batSwing = 0;
let frameCountVal = 0;

// --- エラー表示 ---
function showError(msg) {
  const box = document.getElementById('error-box');
  box.style.display = 'block';
  box.innerHTML += "⚠️ " + msg + "<br>";
  console.error(msg);
}

// --- システムチェック & 起動 ---
async function systemCheck(hand) {
  isRightHand = (hand === 'right');
  
  // 1. HTTPSチェック
  if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
    showError("エラー: https接続ではありません。カメラは起動しません。");
    alert("【重要】\nこのアプリはセキュリティ制限のため、https接続（鍵マーク）のサイトでしか動作しません。\nURLを確認してください。");
    return;
  }

  // UI切り替え
  document.querySelector('#screen-menu .btn').innerText = "起動中...";
  
  // 2. カメラ取得トライ
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: false,
      video: {
        // PC/スマホ両対応のため、facingModeは理想条件(ideal)にする
        facingMode: { ideal: "user" },
        width: { ideal: 640 },
        height: { ideal: 480 }
      }
    });

    // 成功したらビデオ要素にセット
    videoElem.srcObject = stream;
    // 重要：Promiseで再生完了を待つ
    await videoElem.play();
    
    isCameraReady = true;
    
    // AI読み込みへ
    initAI();

  } catch (err) {
    showError("カメラ起動失敗: " + err.name);
    alert("カメラへのアクセスが拒否されたか、見つかりません。\nブラウザの設定を確認してください。");
  }
}

// --- MediaPipe初期化 ---
function initAI() {
  try {
    hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 0, // 0=Lite(軽量), 1=Full
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);
    
    // ループ開始
    processVideo();
    
    // 画面遷移
    appState = 1;
    switchScreen('screen-calib');
    setupCalib('close');

  } catch(e) {
    showError("AI初期化エラー: " + e.message);
  }
}

async function processVideo() {
  if (videoElem.readyState >= 2) {
    await hands.send({image: videoElem});
  }
  requestAnimationFrame(processVideo);
}

function onResults(results) {
  if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
    landmarks = results.multiHandLandmarks[0];
    calcHand();
  } else {
    landmarks = null;
  }
}

// --- 手の計算ロジック ---
function calcHand() {
  if(!landmarks) return;
  
  let w = width; let h = height;
  // 座標取得 (反転処理込み)
  let p0 = {x:(1-landmarks[0].x)*w, y:landmarks[0].y*h}; // 手首
  let p5 = {x:(1-landmarks[5].x)*w, y:landmarks[5].y*h}; // 人差し指基部
  let p4 = {x:(1-landmarks[4].x)*w, y:landmarks[4].y*h}; // 親指先

  // スケール計算（手首〜人差し指基部 = 100mm と仮定）
  let pxBase = dist(p0.x, p0.y, p5.x, p5.y);
  let mmPerPx = 100 / (pxBase || 1); // 0除算防止
  
  // 親指の開き計算
  let pxThumb = dist(p4.x, p4.y, p5.x, p5.y);
  thumbDistMm = Math.floor(pxThumb * mmPerPx);

  // UI更新
  if(appState === 1) {
    document.getElementById('calib-display').innerText = thumbDistMm + " mm";
  }
  document.getElementById('rom-val').innerText = "ROM: " + thumbDistMm + "mm";
}

// --- p5.js 描画ループ ---
function setup() {
  createCanvas(windowWidth, windowHeight);
  background(10); // 初期背景
}

function draw() {
  background(20);

  // 1. カメラ映像の描画 (Coverモード)
  if (isCameraReady && videoElem.readyState >= 2) {
    let vw = videoElem.videoWidth;
    let vh = videoElem.videoHeight;
    
    // アスペクト比計算
    let scaleVal = max(width/vw, height/vh);
    let drawW = vw * scaleVal;
    let drawH = vh * scaleVal;
    let dx = (width - drawW) / 2;
    let dy = (height - drawH) / 2;

    push();
    translate(width, 0); scale(-1, 1); // 左右反転
    // 反転しているので描画位置も調整が必要
    // 画面中心を基準に描画
    imageMode(CENTER);
    image(videoElem, width/2, height/2, drawW, drawH);
    pop();

    // 画面を暗くする
    fill(0, 100); noStroke(); rect(0,0,width,height);
  } else {
    // カメラ未準備時
    fill(255); textAlign(CENTER); textSize(14);
    text("カメラ待機中...", width/2, height/2);
  }

  // 2. ゲーム描画
  if(appState === 2) {
    runGame();
  }

  // 3. 骨格ガイド
  if(landmarks) drawSkeleton();
}

function drawSkeleton() {
  if(!landmarks) return;
  let w = width; let h = height;
  let p5 = {x:(1-landmarks[5].x)*w, y:landmarks[5].y*h};
  let p4 = {x:(1-landmarks[4].x)*w, y:landmarks[4].y*h};
  
  stroke(0, 255, 255); strokeWeight(3);
  line(p5.x, p5.y, p4.x, p4.y);
  fill(255,0,0); noStroke(); circle(p4.x, p4.y, 15);
}

// --- キャリブレーション ---
function setupCalib(mode) {
  const title = document.getElementById('calib-title');
  const msg = document.getElementById('calib-msg');
  const btn = document.querySelector('#screen-calib .btn');
  
  if (mode === 'close') {
    title.innerText = "測定：閉じる";
    msg.innerHTML = "親指を閉じて（グー）<br>ボタンを押してください";
    btn.innerText = "閉じた位置を記録";
    distClose = 0; distOpen = 0;
  } else {
    title.innerText = "測定：開く";
    msg.innerHTML = "親指を最大まで開いて<br>ボタンを押してください";
    btn.innerText = "ゲームスタート";
  }
}

function nextCalib() {
  const title = document.getElementById('calib-title').innerText;
  if(title.includes("閉じる")) {
    distClose = thumbDistMm;
    setupCalib('open');
  } else {
    distOpen = thumbDistMm;
    // エラーチェック
    if(distOpen <= distClose + 5) {
      alert("動きが小さすぎます。しっかり動かして再測定してください。");
      setupCalib('close');
      return;
    }
    startGame();
  }
}

// --- ゲームロジック ---
function startGame() {
  appState = 2;
  switchScreen(null); // 全UI非表示
  document.getElementById('hud').style.display = 'block';
  document.getElementById('rom-val').style.display = 'block';
  
  score = 0; lives = 3; balls = []; panels = [];
  createPanels();
  updateLives();
}

function createPanels() {
  panels = [];
  let pw = width * 0.12; 
  let ph = height * 0.08;
  // 右手なら左側、左手なら右側にパネル配置
  let startX = isRightHand ? width * 0.1 : width * 0.55; 
  
  for(let r=0; r<3; r++){
    for(let c=0; c<3; c++){
      let id = (r*3)+c+1;
      let y = height*0.7 - (r*(ph+10));
      let x = startX + c*(pw+5);
      panels.push({id:id, x:x, y:y, w:pw, h:ph, active:true});
    }
  }
}

function runGame() {
  frameCountVal++;
  
  // スイング計算
  let ratio = map(thumbDistMm, distClose, distOpen, 0, 1);
  batSwing = constrain(ratio, 0, 1);
  
  drawGauge();

  // ボール生成
  if(frameCountVal % 90 === 0) {
    let sx = isRightHand ? 0 : width;
    let tx = isRightHand ? width*0.8 : width*0.2;
    balls.push({
      x:sx, y:height*0.6, 
      vx:(tx-sx)/40, vy:0, 
      active:true, hit:false
    });
  }

  // ボール更新
  let hitX = isRightHand ? width*0.8 : width*0.2;
  for(let i=balls.length-1; i>=0; i--){
    let b = balls[i];
    b.x += b.vx; b.y += b.vy;
    
    fill(255); noStroke(); circle(b.x, b.y, 20);
    
    // ヒット判定
    if(!b.hit && b.active && abs(b.x - hitX) < 50 && batSwing > 0.3) {
      b.hit = true;
      
      // 打ち分けロジック
      let aimRow = 0; // 0:下, 1:中, 2:上
      if(batSwing > 0.66) aimRow = 2;
      else if(batSwing > 0.33) aimRow = 1;

      // 狙った行の適当なパネルを探す
      let targets = panels.filter(p => p.active && Math.floor((p.id-1)/3) === aimRow);
      // なければ全パネルから探す
      if(targets.length === 0) targets = panels.filter(p => p.active);
      
      let target = null;
      if(targets.length > 0) target = targets[Math.floor(random(targets.length))];
      
      let tx = target ? target.x + target.w/2 : (isRightHand?0:width);
      let ty = target ? target.y + target.h/2 : 0;
      
      let dx = tx - b.x; let dy = ty - b.y;
      let len = sqrt(dx*dx + dy*dy);
      b.vx = (dx/len)*30; b.vy = (dy/len)*30;
    }

    // パネル破壊
    if(b.hit && b.active) {
      for(let p of panels) {
        if(p.active && b.x>p.x && b.x<p.x+p.w && b.y>p.y && b.y<p.y+p.h) {
          p.active = false; b.active = false; score+=100; updateLives(); break;
        }
      }
    }
    
    // 画面外
    if(b.x<-100 || b.x>width+100 || b.y<-100 || b.y>height+100) {
      if(!b.hit && b.active) {
        lives--; updateLives();
        if(lives<=0) {
          appState=3; 
          document.getElementById('score-result').innerText = "Score: "+score; 
          switchScreen('screen-result');
        }
      }
      balls.splice(i,1);
    }
  }

  // パネル描画
  let activeCnt = 0;
  for(let p of panels) {
    if(p.active) {
      activeCnt++;
      fill(0,200,0,150); stroke(255); strokeWeight(2);
      rect(p.x, p.y, p.w, p.h);
      fill(255); noStroke(); textAlign(CENTER,CENTER); textSize(24);
      text(p.id, p.x+p.w/2, p.y+p.h/2);
    }
  }
  if(activeCnt === 0 && panels.length > 0) {
    score+=1000; createPanels();
  }
}

function drawGauge() {
  let x = isRightHand ? width-30 : 30;
  let y = height/2; let h = 200;
  fill(100,100); rect(x-5, y-h/2, 10, h);
  let cy = map(batSwing, 0, 1, y+h/2, y-h/2);
  fill(0,255,0); circle(x, cy, 20);
  stroke(255); line(x-10, y-h/6, x+10, y-h/6); line(x-10, y+h/6, x+10, y+h/6);
}

function updateLives() {
  let s = ""; for(let i=0; i<lives; i++) s+="❤️";
  document.getElementById('hud').innerHTML = s + " <span style='font-size:16px'>Score: "+score+"</span>";
}

function switchScreen(id) {
  document.querySelectorAll('.screen').forEach(e => e.classList.remove('active'));
  if(id) document.getElementById(id).classList.add('active');
}

function windowResized(){ resizeCanvas(windowWidth, windowHeight); }
</script>
</body>
</html>
