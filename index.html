<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Thumb Baseball - Struck Out</title>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
    canvas { display: block; position: absolute; top: 0; left: 0; width: 100% !important; height: 100% !important; }
    #loading {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      color: white; font-size: 20px; text-align: center; text-shadow: 2px 2px 4px #000; pointer-events: none;
      z-index: 10;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/addons/p5.sound.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
  <div id="loading">読み込み中...<br>stadium_bg.pngを配置してください</div>

<script>
let videoElement, hands, camera;
let thumbTip = null, indexBase = null, wrist = null;
let handDetected = false;

let gameState = 1; // 1:Step1, 2:Step2, 3:Play, 4:Error
let angleClosed = 0, angleOpen = 0, currentAngle = 0;
let currentProgressPercent = 0; 
let fixedWristPosition = null; 
const ALLOWED_MOVEMENT_RADIUS = 100;

let balls = [];
let panels = []; // ストラックアウトのパネル
let score = 0;
let level = 1; // 現在のレベル
let message = "", messageTimer = 0, messageColor;
let bgImage, bgLoaded = false;
let hitSoundOsc, hitSoundEnv; // 音声用

let batRangeStart, batRangeEnd; 
let guidePositionX, guidePositionY;

function preload() {
  bgImage = loadImage('stadium_bg.png', 
    () => { bgLoaded = true; },
    () => { bgLoaded = false; console.log("画像なし"); }
  );
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  videoElement = createCapture(VIDEO);
  videoElement.size(width, height);
  videoElement.hide();

  // 音の準備（シンプルな合成音）
  hitSoundEnv = new p5.Envelope();
  hitSoundEnv.setADSR(0.001, 0.1, 0.1, 0.1);
  hitSoundEnv.setRange(0.5, 0);
  hitSoundOsc = new p5.Oscillator('triangle');
  hitSoundOsc.amp(hitSoundEnv);
  hitSoundOsc.freq(880);

  batRangeStart = width * 0.85; 
  batRangeEnd = width * 0.55;   
  guidePositionX = width * 0.85;
  guidePositionY = height / 2 + 100;

  // パネルの初期化
  initPanels();

  hands = new Hands({locateFile: (file) => 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/' + file});
  hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
  hands.onResults(onResults);

  camera = new Camera(videoElement.elt, {
    onFrame: async () => { await hands.send({image: videoElement.elt}); },
    width: 1280, height: 720
  });
  camera.start();
}

function initPanels() {
  panels = [];
  let cols = 3; 
  let rows = 3;
  let panelW = width * 0.08;
  let panelH = height * 0.12;
  let startX = width / 2 - panelW * 1.5;
  let startY = height * 0.15; // 画面上部に配置

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      let num = r * 3 + c + 1;
      // 配置順：1 2 3 (上段), 4 5 6 (中段), 7 8 9 (下段)
      panels.push({
        x: startX + c * (panelW + 10),
        y: startY + r * (panelH + 10),
        w: panelW,
        h: panelH,
        num: num,
        active: true
      });
    }
  }
}

function onResults(results) {
  document.getElementById('loading').style.display = 'none';
  if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
    handDetected = true;
    const lm = results.multiHandLandmarks[0];
    thumbTip = createVector((1 - lm[4].x) * width, lm[4].y * height);
    indexBase = createVector((1 - lm[5].x) * width, lm[5].y * height);
    wrist = createVector((1 - lm[0].x) * width, lm[0].y * height);
    currentAngle = p5.Vector.sub(indexBase, wrist).angleBetween(p5.Vector.sub(thumbTip, wrist));
  } else {
    handDetected = false;
    thumbTip = null;
    wrist = null;
  }
}

function touchStarted() { handleInput(); return false; }
function mousePressed() { handleInput(); }

function handleInput() {
  if (getAudioContext().state !== 'running') getAudioContext().resume();
  hitSoundOsc.start(); // 音声エンジン開始

  if (gameState === 4) { resetGame(); return; }

  if (handDetected && thumbTip && wrist) {
    if (gameState === 1) { 
        angleClosed = currentAngle; 
        gameState = 2; 
    } else if (gameState === 2) { 
        angleOpen = currentAngle; 
        fixedWristPosition = createVector(wrist.x, wrist.y);
        gameState = 3; 
    }
  }
}

function resetGame() {
  gameState = 1;
  balls = [];
  score = 0;
  level = 1;
  fixedWristPosition = null;
  initPanels();
}

function draw() {
  // 背景
  if (bgLoaded && bgImage) {
    let imgAspect = bgImage.width / bgImage.height;
    let canvasAspect = width / height;
    let dw, dh, dx, dy;
    if (canvasAspect > imgAspect) { dw=width; dh=width/imgAspect; dx=0; dy=(height-dh)/2; }
    else { dh=height; dw=height*imgAspect; dy=0; dx=(width-dw)/2; }
    image(bgImage, dx, dy, dw, dh);
  } else {
    background(0);
  }

  // ストラックアウトパネル描画（奥にあるのでボールより先に描画）
  drawPanels();

  push();
  translate(width, 0); scale(-1, 1); tint(255, 120);
  image(videoElement, 0, 0, width, height);
  pop();

  drawAlwaysGuide();

  if (gameState === 3) {
    checkHandStability();
    if (gameState === 3) playGame();
  } else if (gameState === 4) {
    drawErrorScreen();
  } else {
    drawSetupUI();
  }
}

function drawPanels() {
  // 全パネルクリアしたら復活
  if (panels.every(p => !p.active)) {
    showMessage("PERFECT! Reset!", color(0, 255, 255));
    setTimeout(initPanels, 1000);
  }

  for (let p of panels) {
    if (p.active) {
      fill(255, 200); stroke(0); strokeWeight(2);
      rect(p.x, p.y, p.w, p.h, 5);
      fill(0); noStroke(); textSize(30); textAlign(CENTER, CENTER);
      text(p.num, p.x + p.w/2, p.y + p.h/2);
    } else {
      // 抜いたパネルの跡
      fill(50, 100); noStroke();
      rect(p.x, p.y, p.w, p.h, 5);
    }
  }
}

function drawAlwaysGuide() {
  noFill

