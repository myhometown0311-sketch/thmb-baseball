import cv2
import mediapipe as mp
import numpy as np
import time

# --- 1. 関数定義: 角度計算 ---
def calculate_angle(a, b, c):
    """3点間の角度を計算 (0〜180度)"""
    a = np.array(a)
    b = np.array(b)
    c = np.array(c)
    
    radians = np.arctan2(c[1]-b[1], c[0]-b[0]) - np.arctan2(a[1]-b[1], a[0]-b[0])
    angle = np.abs(radians*180.0/np.pi)
    
    if angle > 180.0:
        angle = 360 - angle
    return angle

# --- 2. ゲーム設定 ---
# 画面サイズ
WIDTH, HEIGHT = 640, 480

# パネル（的）の設定：3x3のグリッド
rows, cols = 3, 3
panels = [True] * 9  # Trueならパネルが存在、Falseなら破壊済み
panel_margin = 10
panel_width = (WIDTH - 150) // cols  # 右側に情報表示スペースを空ける
panel_height = (HEIGHT - 100) // rows
start_x = 20
start_y = 50

# カーソル位置（初期値）
cursor_pos = 4  # 0~8のインデックス（中心は4）

# ゲーム状態
score = 0
message = "Aim & Press SPACE"
message_color = (255, 255, 255)
last_throw_time = 0

# --- 3. メイン処理 ---
mp_drawing = mp.solutions.drawing_utils
mp_hands = mp.solutions.hands

cap = cv2.VideoCapture(0)
cap.set(3, WIDTH)
cap.set(4, HEIGHT)

with mp_hands.Hands(
    min_detection_confidence=0.7,
    min_tracking_confidence=0.5,
    max_num_hands=1
) as hands:
    
    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break
        
        # 鏡のように反転
        frame = cv2.flip(frame, 1)
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        image.flags.writeable = False
        
        results = hands.process(image)
        
        image.flags.writeable = True
        image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)
        
        current_angle = 0
        
        # ハンドトラッキング処理
        if results.multi_hand_landmarks:
            for hand_landmarks in results.multi_hand_landmarks:
                h, w, _ = image.shape
                
                # 親指の座標取得 (CM, MP, IP/Tip)
                p2 = [hand_landmarks.landmark[2].x * w, hand_landmarks.landmark[2].y * h]
                p3 = [hand_landmarks.landmark[3].x * w, hand_landmarks.landmark[3].y * h]
                p4 = [hand_landmarks.landmark[4].x * w, hand_landmarks.landmark[4].y * h]
                
                # 角度計算（数値化）
                current_angle = calculate_angle(p2, p3, p4)
                
                # 骨格描画
                mp_drawing.draw_landmarks(image, hand_landmarks, mp_hands.HAND_CONNECTIONS)
                
                # 関節横に数値を描画
                cv2.putText(image, str(int(current_angle)), tuple(np.multiply(p3, [1, 1]).astype(int)), 
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2, cv2.LINE_AA)

        # --- カーソル操作ロジック ---
        # 角度(90度〜160度)を、パネルの縦位置(行)にマッピングする
        # Open(160度) -> 上の行 / Close(90度) -> 下の行
        
        # 3段階に行を分ける
        target_row = 1 # デフォルトは真ん中
        
        if current_angle > 140:
            target_row = 0 # 上段 (Open)
        elif current_angle < 110:
            target_row = 2 # 下段 (Close)
        else:
            target_row = 1 # 中段
            
        # 横方向（列）はシンプルにするため、今回は「真ん中の列」固定か、
        # あるいは「時間経過で左右に動く」などが考えられますが、
        # まずは「親指の屈伸で高さを選ぶ」仕組みにします。
        # ここでは簡易的に「真ん中の列（1列目）」を選択しつつ、
        # もし手首の傾き等が取れれば左右もできますが、今回は「高さ制御」に特化します。
        # 簡易版として、常に「真ん中の列」の、選択された行をターゲットにします。
        # ※全抜きするには本来左右移動も必要ですが、まずは上下動作を確認してください。
        
        # カーソル位置の決定 (とりあえず真ん中の列：インデックス 1, 4, 7)
        # 行0 -> パネル1 (index 1)
        # 行1 -> パネル4 (index 4)
        # 行2 -> パネル7 (index 7)
        cursor_pos = target_row * 3 + 1 
        
        # --- 描画：ストラックアウトのパネル ---
        for i in range(9):
            r = i // 3
            c = i % 3
            px = start_x + c * (panel_width + 5)
            py = start_y + r * (panel_height + 5)
            
            # パネルが存在する場合
            if panels[i]:
                color = (0, 200, 0) # 緑
                thickness = -1 # 塗りつぶし
                
                # カーソルが合っている場合
                if i == cursor_pos:
                    color = (0, 100, 255) # オレンジ（ハイライト）
                
                cv2.rectangle(image, (px, py), (px + panel_width, py + panel_height), color, thickness)
                # 番号描画
                cv2.putText(image, str(i+1), (px + panel_width//2 - 10, py + panel_height//2 + 10),
                            cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)
            else:
                # 破壊されたパネル
                cv2.rectangle(image, (px, py), (px + panel_width, py + panel_height), (50, 50, 50), 2)

        # --- 情報表示（右サイド） ---
        info_x = WIDTH - 140
        
        # 1. 角度数値表示（ゲージ削除・数値化）
        cv2.putText(image, "Thumb Angle", (info_x, 80), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (200, 200, 200), 1)
        cv2.putText(image, f"{int(current_angle)} deg", (info_x, 120), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (255, 255, 255), 2)
        
        # 2. 状態判定
        status = "Mid"
        if current_angle > 140: status = "Open (High)"
        elif current_angle < 110: status = "Close (Low)"
        
        cv2.putText(image, status, (info_x, 150), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (100, 255, 255), 1)

        # 3. スコア
        cv2.putText(image, f"Score: {score}", (info_x, 300), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)
        
        # 4. メッセージ
        cv2.putText(image, message, (WIDTH//2 - 100, HEIGHT - 20), cv2.FONT_HERSHEY_SIMPLEX, 0.8, message_color, 2)

        # --- 入力処理（スペースキーで投球） ---
        key = cv2.waitKey(10) & 0xFF
        if key == ord(' '): # スペースキー
            if panels[cursor_pos]: # パネルがある場合
                panels[cursor_pos] = False # 破壊
                score += 100
                message = "HIT!"
                message_color = (0, 255, 0)
            else:
                message = "Miss..."
                message_color = (0, 0, 255)
            last_throw_time = time.time()
        
        # メッセージのリセット
        if time.time() - last_throw_time > 1.0 and message != "Aim & Press SPACE":
            message = "Aim & Press SPACE"
            message_color = (255, 255, 255)

        if key == ord('q'):
            break

        cv2.imshow('Thumb ROM Struck Out', image)

cap.release()
cv2.destroyAllWindows()


