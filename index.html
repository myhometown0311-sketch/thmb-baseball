import cv2
import mediapipe as mp
import numpy as np

# --- 1. 関数定義: 3点間の角度を算出 ---
def calculate_angle(a, b, c):
    """
    3つの座標(a, b, c)から、bを中心とした角度(0〜180度)を計算する関数
    a: 起点 (例: MCP関節)
    b: 中心点 (例: IP関節)
    c: 終点 (例: 指先)
    """
    a = np.array(a) # First
    b = np.array(b) # Mid
    c = np.array(c) # End
    
    # ラジアンから角度を計算
    radians = np.arctan2(c[1]-b[1], c[0]-b[0]) - np.arctan2(a[1]-b[1], a[0]-b[0])
    angle = np.abs(radians*180.0/np.pi)
    
    # 180度を超える場合は補正（内角を取るため）
    if angle > 180.0:
        angle = 360 - angle
        
    return angle

# --- 2. 初期設定 ---
mp_drawing = mp.solutions.drawing_utils
mp_hands = mp.solutions.hands

# Webカメラの起動
cap = cv2.VideoCapture(0)

# MediaPipe Handsのセットアップ
with mp_hands.Hands(
    min_detection_confidence=0.7, # 検出の信頼度閾値
    min_tracking_confidence=0.5,  # 追跡の信頼度閾値
    max_num_hands=1               # 片手のみ検出
) as hands:
    
    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break
        
        # 1. 画像の左右反転（鏡として使うため）
        frame = cv2.flip(frame, 1)
        
        # 2. BGRからRGBへ変換
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        image.flags.writeable = False
        
        # 3. 推論（検出）実行
        results = hands.process(image)
        
        # 4. RGBからBGRへ戻す
        image.flags.writeable = True
        image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)
        
        # ランドマークが検出された場合の処理
        if results.multi_hand_landmarks:
            for hand_landmarks in results.multi_hand_landmarks:
                
                # --- 座標の取得 ---
                h, w, _ = image.shape
                
                # 親指のランドマークインデックス:
                # 2: CM関節 (CMC) - 手首に近い付け根
                # 3: MP関節 (MCP) - 親指の付け根
                # 4: IP関節 (Tip) - 親指の先端
                # ※ここではMP関節(2)・IP関節(3)・指先(4)を使って、IP関節の屈曲角度を見ます
                
                # 座標抽出
                p2 = [hand_landmarks.landmark[2].x * w, hand_landmarks.landmark[2].y * h] # MCP
                p3 = [hand_landmarks.landmark[3].x * w, hand_landmarks.landmark[3].y * h] # IP
                p4 = [hand_landmarks.landmark[4].x * w, hand_landmarks.landmark[4].y * h] # Tip
                
                # 角度計算 (IP関節を中心とした角度)
                angle = calculate_angle(p2, p3, p4)
                
                # --- 判定ロジック (逆転防止済み) ---
                # 親指が伸びている(Open) = 180度に近い
                # 親指が曲がっている(Close) = 角度が小さい
                
                if angle > 160:
                    stage = "Open"
                    status_color = (0, 255, 0) # 緑
                elif angle < 100: # 閾値は調整可能
                    stage = "Close"
                    status_color = (0, 0, 255) # 赤
                else:
                    stage = "Moving"
                    status_color = (255, 255, 0) # 黄
                
                # --- 描画処理 ---
                
                # 1. 骨格の描画
                mp_drawing.draw_landmarks(
                    image, hand_landmarks, mp_hands.HAND_CONNECTIONS,
                    mp_drawing.DrawingSpec(color=(121, 22, 76), thickness=2, circle_radius=4),
                    mp_drawing.DrawingSpec(color=(250, 44, 250), thickness=2, circle_radius=2),
                )
                
                # 2. 関節部分への数値表示
                cv2.putText(image, str(int(angle)), 
                            tuple(np.multiply(p3, [1, 1]).astype(int)), 
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2, cv2.LINE_AA)
                
                # 3. 画面上の情報表示パネル（ゲージ削除済み・数値強調）
                # 背景ボックス
                cv2.rectangle(image, (0,0), (250, 85), (245, 117, 16), -1)
                
                # テキスト: 可動域角度 (ROM Angle)
                cv2.putText(image, 'ROM Angle', (15,20), 
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0,0,0), 1, cv2.LINE_AA)
                cv2.putText(image, str(int(angle)) + " deg", 
                            (15,70), 
                            cv2.FONT_HERSHEY_SIMPLEX, 1.2, (255,255,255), 2, cv2.LINE_AA)
                
                # テキスト: 状態 (Status)
                cv2.putText(image, 'Status', (140,20), 
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0,0,0), 1, cv2.LINE_AA)
                cv2.putText(image, stage, 
                            (140,70), 
                            cv2.FONT_HERSHEY_SIMPLEX, 1.2, (255,255,255), 2, cv2.LINE_AA)

        # 画面出力
        cv2.imshow('Thumb ROM Analysis', image)

        # 'q'キーで終了
        if cv2.waitKey(10) & 0xFF == ord('q'):
            break

cap.release()
cv2.destroyAllWindows()

