<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Thumb Baseball - Full Physics</title>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; background-color: #222; font-family: sans-serif; touch-action: manipulation; }
    
    canvas { display: block; position: absolute; top: 0; left: 0; width: 100% !important; height: 100% !important; z-index: 0; }
    
    /* æ“ä½œç›¤ */
    #overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: flex; flex-direction: row; 
      justify-content: center; align-items: center;
      z-index: 1000; color: white; text-align: center;
      pointer-events: auto;
    }

    #left-panel { width: 45%; padding: 10px; display: flex; justify-content: center; }
    #instruction {
      background: rgba(255, 255, 255, 0.15);
      border: 1px solid #777;
      border-radius: 8px; padding: 15px;
      font-size: 14px; line-height: 1.8; color: white;
      text-align: left; width: 100%; max-width: 400px;
    }

    #right-panel { width: 45%; padding: 10px; display: flex; flex-direction: column; align-items: center; }
    
    h1 { margin: 0 0 20px 0; font-size: 28px; color: #ffff00; text-shadow: 0 0 10px rgba(255,255,0,0.5); }

    .btn-container { display: flex; flex-direction: column; gap: 20px; width: 100%; max-width: 300px; }

    .hand-btn {
      padding: 20px 0; font-size: 22px; font-weight: bold;
      color: #000; background: #ffff00; border: 4px solid #fff; border-radius: 15px; 
      cursor: pointer; width: 100%; 
      box-shadow: 0 5px 15px rgba(255, 255, 0, 0.4);
      transition: transform 0.1s, background 0.1s;
    }
    .hand-btn:active { background: #ffaa00; transform: scale(0.95); }
    
    #statusLog {
      margin-top: 20px; color: #00ff00; font-weight: bold; 
      font-size: 14px; background: #222; border: 1px solid #555;
      padding: 10px; border-radius: 5px; width: 100%; max-width: 300px;
      min-height: 40px; word-wrap: break-word; text-align: left;
    }

    #rawVideo { display: none; }
  </style>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

  <video id="rawVideo" playsinline webkit-playsinline muted autoplay></video>
  
  <div id="overlay">
    <div id="left-panel">
      <div id="instruction">
        <strong>ã€è¨­å®šæ‰‹é †ã€‘</strong><br>
        1. ãƒ—ãƒ¬ã‚¤ã™ã‚‹æ‰‹ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚<br>
        2. <strong>è¦ªæŒ‡ã‚’é–‰ã˜ã¦</strong>ã‚¿ãƒƒãƒ—ï¼ˆæ§‹ãˆï¼‰ã€‚<br>
        3. <strong>è¦ªæŒ‡ã‚’é–‹ã„ã¦</strong>ã‚¿ãƒƒãƒ—ï¼ˆã‚¹ã‚¤ãƒ³ã‚°ï¼‰ã€‚<br>
        âœ <strong>ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆï¼</strong><br>
        <hr style="border:0; border-top:1px solid #555; margin:10px 0;">
        <small><strong>ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ãƒ¢ãƒ¼ãƒ‰</strong><br>ãƒ»ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§å·¦å³ã«æ‰“ã¡åˆ†ã‘å¯èƒ½<br>ãƒ»èŠ¯ã§æ‰ãˆã‚‹ã¨ãƒ›ãƒ¼ãƒ ãƒ©ãƒ³ï¼</small>
      </div>
    </div>

    <div id="right-panel">
      <h1>Thumb Baseball<br><span style="font-size:0.6em">Pro Edition</span></h1>
      <div id="btn-group" class="btn-container">
        <button id="btnRight" class="hand-btn" onclick="handleClick('right')">å³æ‰‹ã§ãƒ—ãƒ¬ã‚¤ âœ‹</button>
        <button id="btnLeft" class="hand-btn" onclick="handleClick('left')">å·¦æ‰‹ã§ãƒ—ãƒ¬ã‚¤ âœ‹</button>
      </div>
      <div id="statusLog">æº–å‚™å®Œäº†ã€‚ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</div>
    </div>
  </div>

<script>
window.onerror = function(msg, url, line) {
  const el = document.getElementById('statusLog');
  if(el) { el.innerHTML = "âš ï¸ ã‚¨ãƒ©ãƒ¼:<br>" + msg; el.style.color = "#ff5555"; }
};

let rawVideo = document.getElementById('rawVideo');
let hands = null;
let camera = null;
let thumbTip = null, indexBase = null, wrist = null;
let handDetected = false;
let isGameStarted = false;
let isRightHand = true; 

let gameState = 1; 
let angleClosed = 0, angleOpen = 0;
let smoothedAngle = 0; 
let fixedWristPosition = null; 

// --- ç‰©ç†æ¼”ç®—ç”¨å¤‰æ•° ---
let batCurrentProgress = 0; // ãƒãƒƒãƒˆã®ç¾åœ¨ä½ç½® (0.0 - 1.0)
let batVelocity = 0;        // ãƒãƒƒãƒˆã®é€Ÿåº¦
// --------------------

let balls = [];
let panels = []; 
let score = 0;
let level = 1; 
let maxLives = 3;
let lives = maxLives;
let combo = 0;

let message = "", messageTimer = 0, messageColor;
let bgImage = null;
let audioCtx = null;

let batOuterX, batInnerX; 
let guidePositionX, guidePositionY;
let panelStartX;

function log(msg) {
  const el = document.getElementById('statusLog');
  if(el) el.innerHTML = msg;
}

function setup() {
  pixelDensity(1);
  let cnv = createCanvas(windowWidth, windowHeight);
  cnv.style('z-index', '-1'); 
  
  loadImage('stadium_bg.png', 
    (img) => { bgImage = img; },
    (err) => { console.log("èƒŒæ™¯ç”»åƒãªã—"); }
  );

  updateLayout();
  initPanels();
  log("æº–å‚™OKã€‚æ‰‹ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚");
}

function draw() {
  if (bgImage) {
    let imgAspect = bgImage.width / bgImage.height;
    let canvasAspect = width / height;
    let dw, dh, dx, dy;
    if (canvasAspect > imgAspect) { dw=width; dh=width/imgAspect; dx=0; dy=(height-dh)/2; }
    else { dh=height; dw=height*imgAspect; dy=0; dx=(width-dw)/2; }
    image(bgImage, dx, dy, dw, dh);
  } else {
    background(34, 139, 34);
    noStroke(); fill(0, 100, 0, 50);
    for(let i=0; i<height; i+=40) rect(0, i, width, 20);
  }

  if (!isGameStarted) return;

  if (rawVideo && rawVideo.readyState >= 2) {
    push();
    translate(width, 0); scale(-1, 1); tint(255, 80); 
    drawingContext.drawImage(rawVideo, 0, 0, width, height);
    pop();
  }

  if (handDetected && wrist && thumbTip) {
    stroke(255, 0, 0); strokeWeight(3); 
    line(wrist.x, wrist.y, thumbTip.x, thumbTip.y);
    fill(255,0,0); noStroke(); circle(thumbTip.x, thumbTip.y, 10);
  }

  handleInput();
  drawPanels();
  drawAlwaysGuide();

  if (gameState === 3) {
    playGame();
  } else if (gameState === 4) {
    drawErrorScreen();
  } else if (gameState === 5) {
    drawGameOverScreen();
  } else {
    drawSetupUI();
  }
}

function handleClick(hand) {
  document.getElementById('btn-group').style.display = 'none';
  log("èµ·å‹•ä¸­...ã‚«ãƒ¡ãƒ©ã‚’è¨±å¯ã—ã¦ãã ã•ã„");
  setTimeout(() => { startSequence(hand); }, 100);
}

async function startSequence(hand) {
  isRightHand = (hand === 'right');
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if(AudioContext) { audioCtx = new AudioContext(); audioCtx.resume(); }
  } catch(e) {}
  updateLayout();
  initPanels();
  startCamera();
}

function startCamera() {
  const constraints = {
    audio: false,
    video: { facingMode: "user", width: { ideal: 640 }, height: { ideal: 480 } }
  };
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    alert("ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ã‚«ãƒ¡ãƒ©éå¯¾å¿œã§ã™"); return;
  }
  navigator.mediaDevices.getUserMedia(constraints)
    .then(stream => {
      rawVideo.srcObject = stream;
      rawVideo.onloadedmetadata = () => {
        rawVideo.play();
        log("AIã‚¨ãƒ³ã‚¸ãƒ³èª­ã¿è¾¼ã¿ä¸­...");
        initMediaPipe(); 
      };
    })
    .catch(err => {
      alert("ã‚«ãƒ¡ãƒ©ã‚¨ãƒ©ãƒ¼: " + err.message);
      document.getElementById('btn-group').style.display = 'flex';
    });
}

function initMediaPipe() {
  if (typeof Hands === 'undefined') {
    log("AIãƒ©ã‚¤ãƒ–ãƒ©ãƒªæœªãƒ­ãƒ¼ãƒ‰ã€‚ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚"); return;
  }
  hands = new Hands({locateFile: (file) => 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/' + file});
  hands.setOptions({
    maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7
  });
  hands.onResults(onResults);
  camera = new Camera(rawVideo, {
    onFrame: async () => { 
      if(rawVideo.videoWidth > 0 && !rawVideo.paused) await hands.send({image: rawVideo}); 
    },
    width: 640, height: 480
  });
  camera.start().then(() => {
    log("å®Œäº†ï¼ã‚²ãƒ¼ãƒ ç”»é¢ã¸...");
    setTimeout(() => {
      document.getElementById('overlay').style.display = 'none';
      isGameStarted = true;
    }, 500);
  });
}

function onResults(results) {
  if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
    handDetected = true;
    const lm = results.multiHandLandmarks[0];
    thumbTip = createVector((1 - lm[4].x) * width, lm[4].y * height);
    indexBase = createVector((1 - lm[5].x) * width, lm[5].y * height);
    wrist = createVector((1 - lm[0].x) * width, lm[0].y * height);
    
    let v1 = p5.Vector.sub(indexBase, wrist);
    let v2 = p5.Vector.sub(thumbTip, wrist);
    let rawAngle = v1.angleBetween(v2);
    
    if (smoothedAngle === 0) smoothedAngle = rawAngle;
    
    // AIã®ã‚¸ãƒƒã‚¿ãƒ¼ï¼ˆéœ‡ãˆï¼‰ã‚’è»½æ¸›ã™ã‚‹ãŸã‚ã®ãƒ•ã‚£ãƒ«ã‚¿
    smoothedAngle = lerp(smoothedAngle, rawAngle, 0.4); 
  } else {
    handDetected = false;
  }
}

function handleInput() {
  if (gameState === 5 || gameState === 4) return;
  if (handDetected) {
    if (gameState === 1) { 
        angleClosed = smoothedAngle; 
        gameState = 2; 
    } else if (gameState === 2) { 
        angleOpen = smoothedAngle;
        fixedWristPosition = createVector(wrist.x, wrist.y);
        gameState = 3; 
        showMessage("START!", color(255, 255, 0));
    }
  }
}

function touchStarted() { 
  if (!isGameStarted) return true; 
  if (gameState === 1 || gameState === 2) handleInput();
  if (gameState === 5 || gameState === 4) resetGame();
  return false; 
}
function mousePressed() { 
  if (!isGameStarted) return true;
  if (gameState === 1 || gameState === 2) handleInput();
  if (gameState === 5 || gameState === 4) resetGame();
}

function resetGame() {
  gameState = 1; balls = []; score = 0; level = 1; lives = maxLives; combo = 0;
  fixedWristPosition = null; initPanels();
  angleClosed = 0; angleOpen = 0; smoothedAngle = 0;
  // ç‰©ç†å¤‰æ•°ã®ãƒªã‚»ãƒƒãƒˆ
  batCurrentProgress = 0;
  batVelocity = 0;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  updateLayout();
  initPanels();
}

function updateLayout() {
  if (isRightHand) {
    batOuterX = width * 0.85; 
    batInnerX = width * 0.50; 
    guidePositionX = width * 0.85;
  } else {
    batOuterX = width * 0.15; 
    batInnerX = width * 0.50; 
    guidePositionX = width * 0.15;
  }
  guidePositionY = height * 0.75;
}

function initPanels() {
  panels = [];
  let cols = 3; let rows = 3;
  let shrinkRate = constrain(1.0 - (level - 1) * 0.1, 0.5, 1.0);
  let basePanelW = width * 0.06; let basePanelH = height * 0.10;
  let panelW = basePanelW * shrinkRate; let panelH = basePanelH * shrinkRate;
  let panelGap = 15 + (1 - shrinkRate) * 20;
  let levelLift = (level - 1) * (height * 0.05);
  
  if (isRightHand) { panelStartX = width * 0.02; } 
  else { 
    let totalPanelW = cols * panelW + (cols - 1) * panelGap;
    panelStartX = width - totalPanelW - width * 0.02; 
  }
  let totalH = rows * panelH + (rows - 1) * panelGap;
  let panelStartY = (height - totalH - height * 0.05) - levelLift; 
  if (panelStartY < height * 0.1) panelStartY = height * 0.1;
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      let num = r * 3 + c + 1;
      panels.push({
        col: c, row: r, 
        x: panelStartX + c * (panelW + panelGap),
        y: panelStartY + r * (panelH + panelGap),
        w: panelW, h: panelH, num: num, active: true
      });
    }
  }
}

function drawPanels() {
  if (panels.every(p => !p.active)) {
    showMessage("PERFECT! Next Level!", color(0, 255, 255));
    if (frameCount % 60 === 0) initPanels(); 
  }
  for (let p of panels) {
    if (p.active) {
      fill(0, 255, 0, 150); stroke(255); strokeWeight(3);
      rect(p.x, p.y, p.w, p.h, 5);
      let txtSize = min(p.w, p.h) * 0.6;
      fill(255); noStroke(); textSize(txtSize); textStyle(BOLD); textAlign(CENTER, CENTER);
      text(p.num, p.x + p.w/2, p.y + p.h/2);
    } else {
      fill(50, 50); stroke(100); strokeWeight(1);
      rect(p.x, p.y, p.w, p.h, 5);
    }
  }
}

function drawAlwaysGuide() {
  noFill(); 
  let centerX = fixedWristPosition ? fixedWristPosition.x : guidePositionX;
  let centerY = fixedWristPosition ? fixedWristPosition.y : guidePositionY;
  
  if (handDetected) {
    stroke(0, 255, 0); 
    if (gameState < 3) fill(0, 255, 0, 50);
  } else {
    stroke(255, 0, 0); noFill();
  }
  strokeWeight(4); ellipse(centerX, centerY, 120, 120); 
  strokeWeight(2); rect(centerX - 175, centerY - 250, 350, 350, 20);
}

function drawSetupUI() {
  textAlign(CENTER, CENTER); textSize(28); fill(255); stroke(0); strokeWeight(4);
  let uiX = guidePositionX; let uiY = guidePositionY - 250;
  let textOffset = isRightHand ? -150 : 150;

  if (!handDetected) { text("ã‚«ãƒ¡ãƒ©ã«æ‰‹ã‚’æ˜ ã—ã¦ãã ã•ã„", width/2, height/2); return; }
  
  if (gameState === 1) {
      text(`ã€è¨­å®š1/2ã€‘è¦ªæŒ‡ã‚’é–‰ã˜ã¦ã‚¿ãƒƒãƒ—`, uiX + textOffset, uiY);
  } else if (gameState === 2) {
      text(`ã€è¨­å®š2/2ã€‘è¦ªæŒ‡ã‚’é–‹ã„ã¦ã‚¿ãƒƒãƒ—`, uiX + textOffset, uiY);
  }
}

function drawErrorScreen() {
  fill(0, 150); rect(0, 0, width, height);
  textAlign(CENTER, CENTER); textSize(40); fill(255, 50, 50); stroke(255); strokeWeight(5);
  text("æ‰‹ãŒå‹•ãã™ãã§ã™ï¼", width/2, height/2 - 50);
  textSize(24); fill(255); noStroke();
  text("æ‰‹é¦–ã‚’å›ºå®šã—ã¦ãã ã•ã„ã€‚\nç”»é¢ã‚¿ãƒƒãƒ—ã§å†é–‹", width/2, height/2 + 50);
}

function drawGameOverScreen() {
  fill(0, 200); rect(0, 0, width, height);
  textAlign(CENTER, CENTER); 
  fill(255, 50, 50); stroke(255); strokeWeight(5); textSize(60);
  text("GAME OVER", width/2, height/2 - 50);
  fill(255); noStroke(); textSize(30);
  text(`Total Score: ${score}`, width/2, height/2 + 30);
  textSize(24); text("ç”»é¢ã‚¿ãƒƒãƒ—ã§ãƒªãƒˆãƒ©ã‚¤", width/2, height/2 + 100);
}

// â˜…â˜…â˜… ãƒãƒƒãƒˆç‰©ç†æ¼”ç®—ãƒ­ã‚¸ãƒƒã‚¯ â˜…â˜…â˜…
function playGame() {
  // 1. æŒ‡ã®è§’åº¦ã‹ã‚‰ã€Œç›®æ¨™åœ°ç‚¹(Target)ã€ã‚’ç®—å‡º
  let rawTarget = map(smoothedAngle, angleClosed, angleOpen, 0, 1);
  let target = constrain(rawTarget, 0, 1);

  // 2. ç‰©ç†æŒ™å‹•ã®è¨ˆç®—ï¼ˆãƒãƒã¨ãƒ€ãƒ³ãƒ‘ãƒ¼ï¼‰
  let distance = target - batCurrentProgress;
  
  // ãƒãƒã®åŠ›ï¼šè·é›¢ã«å¿œã˜ã¦åŠ é€Ÿ
  let force = distance * 0.08;
  batVelocity += force;

  // æ‘©æ“¦ï¼ˆæ¸›è¡°ï¼‰ï¼šé€Ÿåº¦ã‚’å¾ã€…ã«è½ã¨ã™
  batVelocity *= 0.92;

  // ä½ç½®ã®æ›´æ–°
  batCurrentProgress += batVelocity;

  // 3. å€¤ã®æç”»ã¸ã®åæ˜ 
  let progress = constrain(batCurrentProgress, -0.1, 1.1);

  // ãƒãƒƒãƒˆã®ä½ç½®è¨ˆç®—
  let batX = map(progress, 0, 1, batOuterX, batInnerX);
  
  // è§’åº¦è¨ˆç®—
  let rotateAngle;
  if (isRightHand) rotateAngle = map(progress, 0, 1, PI/4, -PI/4); 
  else rotateAngle = map(progress, 0, 1, -PI/4, PI/4);
  
  // ãƒãƒƒãƒˆã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åˆ¤å®š
  let isBatActive = (progress > 0.05); 
  let batY = guidePositionY - 80;
  
  push();
  translate(batX, batY);
  rotate(rotateAngle);
  
  if (isBatActive) { 
    // ã‚¹ã‚¤ãƒ³ã‚°ã‚¹ãƒ”ãƒ¼ãƒ‰ãŒé€Ÿã„ã¨ãã¯è‰²ã‚’å¤‰ãˆã‚‹
    let speed = abs(batVelocity);
    if (speed > 0.03) fill(255, 0, 0); 
    else if (progress > 0.8) fill(255, 100, 100); 
    else fill(255, 255, 0); 
    stroke(0); 
  } else { 
    fill(100, 150); noStroke(); 
  }
  rect(-15, 0, 30, 140, 10); 
  
  if (!isBatActive) { 
    fill(255); textSize(24); textAlign(CENTER); noStroke(); 
    rotate(isRightHand ? -PI/4 : PI/4); 
    text("WAIT", 0, -30); 
  }
  pop();

  if (balls.length === 0 && frameCount % 60 === 0) balls.push(new Ball(level));

  for (let i = balls.length - 1; i >= 0; i--) {
    let b = balls[i]; b.update(); b.display();
    
    let distToGuide = dist(b.x, b.y, guidePositionX, guidePositionY);
    let inZone = (distToGuide < 200); 
    let hitThreshold = 350; 
    
    // ãƒ’ãƒƒãƒˆåˆ¤å®š
    if (isBatActive && !b.isHit && inZone && dist(b.x, b.y, batX, batY) < hitThreshold) {
      playHitSound(); 
      b.hit(progress); 
    }

    if (b.isHit) {
      for (let p of panels) {
        if (p.active && b.x > p.x && b.x < p.x + p.w && b.y > p.y && b.y < p.y + p.h) {
          p.active = false; score++; combo++;
          if (combo > 40) showMessage("GODLIKE!!", color(255, 0, 0));
          else if (combo > 30) showMessage("LEGENDARY!", color(255, 0, 255));
          else if (combo > 20) showMessage("UNSTOPPABLE!", color(255, 100, 0));
          else if (combo > 10) showMessage("GREAT!", color(255, 255, 0));
          else showMessage("NICE HIT!", color(255, 255, 0));
          checkLevelUp(); balls.splice(i, 1); break;
        }
      }
    }

    if (b.y > height + 100 || b.y < -300 || b.x < -200 || b.x > width + 200) {
      if (!b.isHit) {
        lives--; combo = 0; showMessage("MISS...", color(100, 100, 255));
        if (lives <= 0) gameState = 5;
      }
      balls.splice(i, 1);
    }
  }
  drawGameUI(progress);
}

function checkLevelUp() {
  if (score > 0 && score % 10 === 0) { level++; showMessage(`LEVEL UP! Lv.${level}`, color(0, 255, 0)); }
}

function playHitSound() {
  if (audioCtx && audioCtx.state === 'running') {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(600, audioCtx.currentTime);
    osc.frequency.linearRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.1);
  }
}

function drawGameUI(progress) {
  fill(255); stroke(0); strokeWeight(4);
  textAlign(RIGHT, TOP); textSize(32); 
  text(`SCORE: ${score}`, width - 20, 20); text(`Lv.${level}`, width - 20, 60);

  if (combo > 1) { fill(255, 200, 0); textSize(40); text(`${combo} COMBO!`, width - 20, 110); }

  textAlign(LEFT, TOP); fill(255, 50, 50); textSize(32);
  let hearts = "â¤ï¸".repeat(lives); let empty = "ğŸ¤".repeat(maxLives - lives);
  text(`Life: ${hearts}${empty}`, 20, 20);

  if (messageTimer > 0) {
    textAlign(CENTER); fill(messageColor); stroke(0); strokeWeight(4);
    textSize(60); text(message, width/2, height/3); messageTimer--;
  }
}

function showMessage(t, c) { message = t; messageColor = c; messageTimer = 60; }

// --- â˜…ä¿®æ­£ç‰ˆ Ballã‚¯ãƒ©ã‚¹ï¼ˆæ‰“çƒæ–¹å‘åˆ¶å¾¡æ©Ÿèƒ½ä»˜ãï¼‰ ---
class Ball {
  constructor(currentLevel) {
    this.startX = isRightHand ? width * 0.1 : width * 0.9;
    this.startY = height * 0.6; 
    this.x = this.startX; 
    this.y = this.startY; 

    // ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸãƒœãƒ¼ãƒ«ã®åˆé€Ÿ
    let baseSpeed = 6 + (currentLevel - 1) * 1.5; 
    let speed = random(baseSpeed, baseSpeed + 2); 
    
    // ãƒ›ãƒ¼ãƒ ãƒ™ãƒ¼ã‚¹ï¼ˆã‚¬ã‚¤ãƒ‰æ ï¼‰ã«å‘ã‹ã£ã¦æŠ•ã’ã‚‹
    let homeBaseCenterX = guidePositionX;
    let targetX = random(homeBaseCenterX - 50, homeBaseCenterX + 50);
    let targetY = guidePositionY - 80; 
    
    let dirX = targetX - this.startX; 
    let dirY = targetY - this.startY;
    let distLen = sqrt(dirX*dirX + dirY*dirY);
    
    this.vx = (dirX / distLen) * speed; 
    this.vy = (dirY / distLen) * speed;
    
    this.isHit = false; 
    this.ballColor = color(255);
    this.radius = 15;
  }

  update() { 
    this.x += this.vx; 
    this.y += this.vy; 
    
    // é‡åŠ›ï¼ˆæ‰“çƒã®ã¿ï¼‰
    if (this.isHit) {
      this.vy += 0.5; // ãƒœãƒ¼ãƒ«ãŒæ”¾ç‰©ç·šã‚’æãã‚ˆã†ã«é‡åŠ›ã‚’ã‹ã‘ã‚‹
      this.radius = lerp(this.radius, 10, 0.05); // é ãã«è¡Œãã«ã¤ã‚Œã¦å°ã•ãè¦‹ã›ã‚‹ï¼ˆé è¿‘æ³•ï¼‰
    }
  }

  display() { 
    fill(this.ballColor); 
    stroke(0); 
    strokeWeight(1); 
    ellipse(this.x, this.y, this.radius * 2); 
  }

  hit(progress) {
    this.isHit = true; 
    this.ballColor = color(255, 255, 0);

    // --- 1. å·¦å³ã®æ‰“ã¡åˆ†ã‘ãƒ­ã‚¸ãƒƒã‚¯ (ã‚¿ã‚¤ãƒŸãƒ³ã‚°ï¼æ–¹å‘) ---
    // progressãŒå°ã•ã„(æŒ¯ã‚Šå§‹ã‚) = é…ã‚Œ = æµã—æ‰“ã¡
    // progressãŒå¤§ãã„(æŒ¯ã‚Šåˆ‡ã‚Š) = æ—©ã„ = å¼•ã£å¼µã‚Š
    
    let wideScreen = width * 1.5; 
    let leftEdge = -width * 0.25;
    let rightEdge = width * 1.25;

    let targetX;
    if (isRightHand) {
      // å³æ‰“è€…ï¼šæ—©ã„(0.9)â†’ãƒ¬ãƒ•ãƒˆ(å·¦)ã€é…ã„(0.3)â†’ãƒ©ã‚¤ãƒˆ(å³)
      targetX = map(progress, 0.3, 0.8, rightEdge, leftEdge);
    } else {
      // å·¦æ‰“è€…ï¼šæ—©ã„(0.9)â†’ãƒ©ã‚¤ãƒˆ(å³)ã€é…ã„(0.3)â†’ãƒ¬ãƒ•ãƒˆ(å·¦)
      targetX = map(progress, 0.3, 0.8, leftEdge, rightEdge);
    }

    // --- 2. é«˜ã•ã®ãƒ­ã‚¸ãƒƒã‚¯ (ã‚¹ã‚¤ãƒ¼ãƒˆã‚¹ãƒãƒƒãƒˆ) ---
    // 0.55ä»˜è¿‘ã§æ‰ãˆã‚‹ã¨ã€ŒèŠ¯ã€ã€‚é ãã¸é£›ã¶ã€‚ã‚ºãƒ¬ã‚‹ã¨ã‚´ãƒ­ã€‚
    let sweetSpot = 0.55;
    let impactQuality = 1.0 - abs(progress - sweetSpot) * 2.0; // 1.0ãŒæœ€é«˜ã€ã‚ºãƒ¬ã‚‹ã¨ä¸‹ãŒã‚‹
    impactQuality = constrain(impactQuality, 0.2, 1.0); // æœ€ä½ä¿è¨¼

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®Yåº§æ¨™ï¼ˆé«˜ã•ï¼‰
    // èŠ¯ãªã‚‰ç”»é¢ä¸Šéƒ¨ï¼ˆãƒ‘ãƒãƒ«æ–¹å‘ï¼‰ã€å¤–ã™ã¨ç”»é¢ä¸‹éƒ¨ï¼ˆã‚´ãƒ­ï¼‰
    let panelTop = panels[0].y - 100; // ãƒ›ãƒ¼ãƒ ãƒ©ãƒ³
    let ground = height + 100;        // ã‚´ãƒ­
    
    let targetY = map(impactQuality, 0.2, 1.0, ground, panelTop);

    // --- 3. æ‰“çƒé€Ÿåº¦ã®è¨ˆç®— ---
    // èŠ¯ã«è¿‘ã„ã»ã©é€Ÿã„
    let flySpeed = 25 * impactQuality + 10; 

    // ãƒ™ã‚¯ãƒˆãƒ«è¨ˆç®—
    let dx = targetX - this.x; 
    let dy = targetY - this.y;
    let distLen = sqrt(dx*dx + dy*dy);
    
    this.vx = (dx / distLen) * flySpeed; 
    this.vy = (dy / distLen) * flySpeed;
  }
}
</script>
</body>
</html>
