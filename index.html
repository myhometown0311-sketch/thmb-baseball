<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Thumb Baseball - Universal</title>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; background-color: #000; font-family: sans-serif; touch-action: none; }
    canvas { display: block; position: absolute; top: 0; left: 0; width: 100% !important; height: 100% !important; z-index: 1; }
    
    /* ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
    #overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      z-index: 100; color: white; text-align: center;
    }
    
    .btn-container {
      display: flex; gap: 20px; margin-top: 30px;
    }

    .hand-btn {
      padding: 20px 40px; font-size: 20px; font-weight: bold;
      color: #000; background: #ffff00; border: 4px solid #fff; border-radius: 50px; cursor: pointer;
      box-shadow: 0 0 20px rgba(255, 255, 0, 0.5);
      -webkit-tap-highlight-color: transparent;
    }
    .hand-btn:active { transform: scale(0.95); background: #cccc00; }

    #debugLog {
      position: fixed; top: 0; left: 0; width: 100%; 
      background: rgba(0,0,0,0.5); color: #00ff00; 
      font-size: 10px; font-family: monospace; padding: 2px; 
      z-index: 999; pointer-events: none;
    }
    
    /* ç”Ÿãƒ“ãƒ‡ã‚ªã¯éè¡¨ç¤ºï¼ˆp5ã§æç”»ã™ã‚‹ãŸã‚ï¼‰ */
    #rawVideo { display: none; }
  </style>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/addons/p5.sound.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

  <div id="debugLog">ã‚·ã‚¹ãƒ†ãƒ å¾…æ©Ÿä¸­...</div>
  <video id="rawVideo" playsinline webkit-playsinline muted autoplay></video>

  <div id="overlay">
    <h1 style="margin:0; font-size:24px;">Thumb Baseball</h1>
    <p style="font-size:14px; color:#ccc;">ã‚¹ãƒãƒ›ã‚’ã€Œæ¨ªç”»é¢ã€ã«ã—ã¦ãã ã•ã„</p>
    
    <div id="instruction" style="margin: 20px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 10px; text-align: left; font-size: 12px; max-width: 80%;">
      <strong>ã€éŠã³æ–¹ãƒ»æ‰‹é †ã€‘</strong><br>
      1. ä¸‹ã®ãƒœã‚¿ãƒ³ã§ã€Œãƒ—ãƒ¬ã‚¤ã™ã‚‹æ‰‹ã€ã‚’é¸ã³ã¾ã™ã€‚<br>
      2. ã‚«ãƒ¡ãƒ©ã®è¨±å¯ã‚’æ±‚ã‚ã‚‰ã‚ŒãŸã‚‰ã€Œè¨±å¯ã€ã—ã¦ãã ã•ã„ã€‚<br>
      3. ä¸¸ã„ã‚¬ã‚¤ãƒ‰ã«æ‰‹é¦–ã‚’åˆã‚ã›ã¾ã™ã€‚<br>
      4. <strong>ã€å¯å‹•åŸŸæ¸¬å®šã€‘</strong>ã‚’è¡Œã„ã¾ã™ï¼ˆæŒ‡ç¤ºã«å¾“ã„ã€é–‰ã˜ã‚‹â†’é–‹ãï¼‰ã€‚<br>
      5. ã‚²ãƒ¼ãƒ é–‹å§‹ï¼ä¸¸ã„ã‚¬ã‚¤ãƒ‰ã®ä¸­ã§è¦ªæŒ‡ã‚’ç´ æ—©ãé–‹ã„ã¦ãƒãƒƒãƒˆã‚’æŒ¯ã‚Šã¾ã™ã€‚<br>
      6. ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚ˆããƒ‘ãƒãƒ«ã‚’ç‹™ã„æ’ƒã¡ã¾ã—ã‚‡ã†ï¼
    </div>

    <div class="btn-container">
      <button class="hand-btn" onclick="selectHand('right')">å³æ‰‹ã§ãƒ—ãƒ¬ã‚¤</button>
      <button class="hand-btn" onclick="selectHand('left')">å·¦æ‰‹ã§ãƒ—ãƒ¬ã‚¤</button>
    </div>
  </div>

<script>
// --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
let rawVideo = document.getElementById('rawVideo');
let hands = null;
let camera = null;
let thumbTip = null, indexBase = null, wrist = null;
let handDetected = false;
let isGameStarted = false;
let isRightHand = true; // true:å³æ‰‹, false:å·¦æ‰‹

let gameState = 1; 
let angleClosed = 0, angleOpen = 0, currentAngle = 0;
let currentProgressPercent = 0; 
let fixedWristPosition = null; 
const ALLOWED_MOVEMENT_RADIUS = 120;

let balls = [];
let panels = []; 
let score = 0;
let level = 1; 
let maxLives = 3;
let lives = maxLives;
let combo = 0;

let currentCm = 0;

let message = "", messageTimer = 0, messageColor;
let bgImage = null;
let hitSoundOsc, hitSoundEnv; 

let batRangeStart, batRangeEnd; 
let guidePositionX, guidePositionY;
let panelStartX, panelStartY;

function log(msg) {
  const el = document.getElementById('debugLog');
  if(el) el.innerText = msg;
  console.log(msg);
}

// --- åˆæœŸåŒ– ---
function setup() {
  pixelDensity(1);
  let cnv = createCanvas(windowWidth, windowHeight);
  cnv.style('z-index', '1');
  
  loadImage('stadium_bg.png', 
    (img) => { bgImage = img; log("ç”»åƒOK"); },
    () => { log("ç”»åƒãªã—(é»’èƒŒæ™¯)"); }
  );
  
  // åˆæœŸãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼ˆå³æ‰‹ä»®å®šï¼‰
  updateLayout();
  initPanels();
}

// --- æ‰‹ã®é¸æŠã¨ã‚¹ã‚¿ãƒ¼ãƒˆ ---
async function selectHand(hand) {
  isRightHand = (hand === 'right');
  
  // ãƒœã‚¿ãƒ³ã‚’æ¶ˆã™
  document.getElementById('overlay').style.display = 'none'; // ä¸€æ—¦æ¶ˆã•ãšã«ãƒ­ãƒ¼ãƒ‰ä¸­ã«ã™ã‚‹ã‹ã€ã‚ã‚‹ã„ã¯æ¶ˆã—ã¦ãƒ­ãƒ¼ãƒ‰è¡¨ç¤º
  document.querySelector('.btn-container').style.display = 'none';
  document.getElementById('instruction').innerHTML = "èµ·å‹•ä¸­...<br>ã‚«ãƒ¡ãƒ©ã®è¨±å¯ã‚’å‡ºã—ã¦ãã ã•ã„";
  
  log(isRightHand ? "å³æ‰‹ãƒ¢ãƒ¼ãƒ‰èµ·å‹•..." : "å·¦æ‰‹ãƒ¢ãƒ¼ãƒ‰èµ·å‹•...");

  try {
    await userStartAudio();
    initAudio();
  } catch(err) { console.log(err); }

  // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå†è¨ˆç®—
  updateLayout();
  initPanels();

  startNativeCamera();
}

// --- Android/iOSå…±é€š ã‚«ãƒ¡ãƒ©èµ·å‹• ---
function startNativeCamera() {
  const constraints = {
    audio: false,
    video: { 
      facingMode: "user", 
      width: { ideal: 640 }, 
      height: { ideal: 480 } 
    }
  };

  navigator.mediaDevices.getUserMedia(constraints)
    .then(stream => {
      rawVideo.srcObject = stream;
      // Androidã§ã®å†ç”Ÿäº’æ›æ€§ã®ãŸã‚
      rawVideo.onloadedmetadata = () => {
        rawVideo.play();
        initMediaPipe();
      };
    })
    .catch(err => {
      alert("ã‚«ãƒ¡ãƒ©èµ·å‹•ã‚¨ãƒ©ãƒ¼: " + err.message + "\nãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
      log("Camera Error: " + err.message);
    });
}

function initMediaPipe() {
  if (typeof Hands === 'undefined') return;

  hands = new Hands({locateFile: (file) => 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/' + file});
  hands.setOptions({
    maxNumHands: 1, 
    modelComplexity: 0, // è»½é‡ãƒ¢ãƒ¼ãƒ‰
    minDetectionConfidence: 0.5, 
    minTrackingConfidence: 0.5
  });
  hands.onResults(onResults);

  camera = new Camera(rawVideo, {
    onFrame: async () => { 
      if(rawVideo.videoWidth > 0 && !rawVideo.paused) {
        await hands.send({image: rawVideo}); 
      }
    },
    width: 640, height: 480
  });
  
  camera.start().then(() => {
    document.getElementById('overlay').style.display = 'none';
    isGameStarted = true;
    log("Game Started!");
  });
}

function initAudio() {
  hitSoundEnv = new p5.Envelope();
  hitSoundEnv.setADSR(0.001, 0.1, 0.2, 0.5); 
  hitSoundEnv.setRange(0.8, 0); 
  hitSoundOsc = new p5.Oscillator('triangle'); 
  hitSoundOsc.amp(hitSoundEnv);
  hitSoundOsc.freq(800);
  hitSoundOsc.start(); 
}

function onResults(results) {
  if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
    handDetected = true;
    const lm = results.multiHandLandmarks[0];
    
    // åº§æ¨™å–å¾— (å·¦å³åè»¢å‡¦ç†ã¯æç”»æ™‚ã«scale(-1,1)ã§è¡Œã†ãŸã‚ã€ã“ã“ã§ã¯ãã®ã¾ã¾å–å¾—)
    thumbTip = createVector((1 - lm[4].x) * width, lm[4].y * height);
    indexBase = createVector((1 - lm[5].x) * width, lm[5].y * height);
    wrist = createVector((1 - lm[0].x) * width, lm[0].y * height);
    
    // è§’åº¦è¨ˆç®—
    currentAngle = p5.Vector.sub(indexBase, wrist).angleBetween(p5.Vector.sub(thumbTip, wrist));
  } else {
    handDetected = false;
    thumbTip = null;
    wrist = null;
  }
}

// --- å…¥åŠ›ãƒãƒ³ãƒ‰ãƒ© ---
function handleInput() {
  if (!isGameStarted) return;
  if (getAudioContext().state !== 'running') getAudioContext().resume();
  if (gameState === 5 || gameState === 4) { resetGame(); return; }

  if (handDetected && thumbTip && wrist) {
    if (gameState === 1) { 
        angleClosed = currentAngle; 
        gameState = 2; 
    } else if (gameState === 2) { 
        angleOpen = currentAngle; 
        fixedWristPosition = createVector(wrist.x, wrist.y);
        gameState = 3; 
    }
  }
}

function touchStarted() { handleInput(); return false; }
function mousePressed() { handleInput(); }

function resetGame() {
  gameState = 1; 
  balls = [];
  score = 0;
  level = 1;
  lives = maxLives;
  combo = 0;
  fixedWristPosition = null;
  initPanels();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  updateLayout();
  let oldPanels = panels;
  initPanels();
  if (oldPanels.length === panels.length) {
    for(let i=0; i<panels.length; i++) panels[i].active = oldPanels[i].active;
  }
}

// --- ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆèª¿æ•´ (å·¦å³å¯¾å¿œ) ---
function updateLayout() {
  if (isRightHand) {
    // å³æ‰‹ãƒ¢ãƒ¼ãƒ‰: ã‚¬ã‚¤ãƒ‰å³ã€ãƒ‘ãƒãƒ«å·¦
    batRangeStart = width * 0.85; 
    batRangeEnd = width * 0.55;   
    guidePositionX = width * 0.85;
  } else {
    // å·¦æ‰‹ãƒ¢ãƒ¼ãƒ‰: ã‚¬ã‚¤ãƒ‰å·¦ã€ãƒ‘ãƒãƒ«å³
    batRangeStart = width * 0.15; 
    batRangeEnd = width * 0.45;   
    guidePositionX = width * 0.15;
  }
  guidePositionY = height / 2 + 100;
}

function initPanels() {
  panels = [];
  let cols = 3; 
  let rows = 3;
  let shrinkRate = constrain(1.0 - (level - 1) * 0.1, 0.5, 1.0);
  let basePanelW = width * 0.06;
  let basePanelH = height * 0.10;
  let panelW = basePanelW * shrinkRate;
  let panelH = basePanelH * shrinkRate;
  let panelGap = 15 + (1 - shrinkRate) * 20;

  let levelLift = (level - 1) * (height * 0.05);
  
  // ãƒ‘ãƒãƒ«é–‹å§‹ä½ç½®ï¼ˆå·¦å³ã§åè»¢ï¼‰
  if (isRightHand) {
    panelStartX = width * 0.02; // å·¦å´
  } else {
    // å³å´é…ç½®: å…¨å¹… - (ãƒ‘ãƒãƒ«å…¨å¹… + ãƒãƒ¼ã‚¸ãƒ³)
    let totalPanelW = cols * panelW + (cols - 1) * panelGap;
    panelStartX = width - totalPanelW - width * 0.02; 
  }

  let totalH = rows * panelH + (rows - 1) * panelGap;
  let panelStartY = (height - totalH - height * 0.05) - levelLift; 
  if (panelStartY < height * 0.1) panelStartY = height * 0.1;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      let num = r * 3 + c + 1;
      panels.push({
        col: c, row: r, 
        x: panelStartX + c * (panelW + panelGap),
        y: panelStartY + r * (panelH + panelGap),
        w: panelW, h: panelH,
        num: num,
        active: true
      });
    }
  }
}

// --- æç”»ãƒ«ãƒ¼ãƒ— ---
function draw() {
  background(0);
  if (bgImage) {
    let imgAspect = bgImage.width / bgImage.height;
    let canvasAspect = width / height;
    let dw, dh, dx, dy;
    if (canvasAspect > imgAspect) { dw=width; dh=width/imgAspect; dx=0; dy=(height-dh)/2; }
    else { dh=height; dw=height*imgAspect; dy=0; dx=(width-dw)/2; }
    
    // èƒŒæ™¯ã‚‚å·¦å³åè»¢ã•ã›ã‚‹ï¼Ÿ ã„ã‚„ã€ã‚¹ã‚¿ã‚¸ã‚¢ãƒ ã¯ãã®ã¾ã¾ã®æ–¹ãŒè‡ªç„¶ã‹ã€‚
    // ãã®ã¾ã¾æç”»
    image(bgImage, dx, dy, dw, dh);
  }

  if (!isGameStarted) return;

  if (rawVideo && rawVideo.readyState >= 2) {
    push();
    translate(width, 0); scale(-1, 1); tint(255, 120);
    drawingContext.drawImage(rawVideo, 0, 0, width, height);
    pop();
  }

  drawPanels();
  drawAlwaysGuide();

  if (gameState === 3) {
    checkHandStability();
    playGame();
  } else if (gameState === 4) {
    drawErrorScreen();
  } else if (gameState === 5) {
    drawGameOverScreen();
  } else {
    drawSetupUI();
  }
}

function drawPanels() {
  if (panels.every(p => !p.active)) {
    showMessage("PERFECT! Next Level!", color(0, 255, 255));
    if (frameCount % 60 === 0) initPanels(); 
  }
  for (let p of panels) {
    if (p.active) {
      fill(0, 255, 0, 150); stroke(255); strokeWeight(3);
      rect(p.x, p.y, p.w, p.h, 5);
      let txtSize = min(p.w, p.h) * 0.6;
      fill(255); noStroke(); textSize(txtSize); textStyle(BOLD); textAlign(CENTER, CENTER);
      text(p.num, p.x + p.w/2, p.y + p.h/2);
    } else {
      fill(50, 50); stroke(100); strokeWeight(1);
      rect(p.x, p.y, p.w, p.h, 5);
    }
  }
}

function drawAlwaysGuide() {
  noFill(); 
  let centerX = fixedWristPosition ? fixedWristPosition.x : guidePositionX;
  let centerY = fixedWristPosition ? fixedWristPosition.y : guidePositionY;
  
  if (handDetected) {
    stroke(0, 255, 0); 
    if (gameState < 3) fill(0, 255, 0, 50);
  } else {
    stroke(255, 0, 0); noFill();
  }
  
  strokeWeight(4); 
  ellipse(centerX, centerY, 120, 120); 
  strokeWeight(2); rect(centerX, centerY - 150, 350, 450, 20);
}

function checkHandStability() {
  if (!wrist || !fixedWristPosition) return;
  if (dist(wrist.x, wrist.y, fixedWristPosition.x, fixedWristPosition.y) > ALLOWED_MOVEMENT_RADIUS) {
    gameState = 4;
  }
}

function drawSetupUI() {
  textAlign(CENTER, CENTER); textSize(28); fill(255); stroke(0); strokeWeight(4);
  let uiX = guidePositionX; 
  let uiY = guidePositionY - 280;
  
  // æ–‡å­—ä½ç½®ã®å¾®èª¿æ•´ï¼ˆå·¦å³ã§å¤‰ãˆã‚‹ï¼‰
  let textOffset = isRightHand ? -150 : 150;

  if (!handDetected) {
    text("ã‚«ãƒ¡ãƒ©ã«æ‰‹ã‚’æ˜ ã—ã¦ãã ã•ã„", width/2, height/2);
    return;
  }

  if (gameState === 1) text("ã€å¯å‹•åŸŸæ¸¬å®š 1/2ã€‘\næ‰‹é¦–ã‚’ä¸¸ã«åˆã‚ã›ã¦\nè¦ªæŒ‡ã‚’é–‰ã˜ã¦ã‚¿ãƒƒãƒ—", uiX + textOffset, uiY);
  else if (gameState === 2) text("ã€å¯å‹•åŸŸæ¸¬å®š 2/2ã€‘\næ‰‹é¦–ã‚’å‹•ã‹ã•ãšã«ï¼\nè¦ªæŒ‡ã‚’å…¨é–‹ã«ã—ã¦ã‚¿ãƒƒãƒ—", uiX + textOffset, uiY);
}

function drawErrorScreen() {
  fill(0, 150); rect(0, 0, width, height);
  textAlign(CENTER, CENTER); textSize(40); fill(255, 50, 50); stroke(255); strokeWeight(5);
  text("æ‰‹ãŒå‹•ãã¾ã—ãŸï¼", width/2, height/2 - 50);
  textSize(24); fill(255); noStroke();
  text("æ‰‹é¦–ã‚’ä¸¸ã®ä½ç½®ã«æˆ»ã—ã¦ãã ã•ã„ã€‚\nç”»é¢ã‚¿ãƒƒãƒ—ã§ãƒªã‚»ãƒƒãƒˆ", width/2, height/2 + 50);
}

function drawGameOverScreen() {
  fill(0, 200); rect(0, 0, width, height);
  textAlign(CENTER, CENTER); 
  fill(255, 50, 50); stroke(255); strokeWeight(5); textSize(60);
  text("GAME OVER", width/2, height/2 - 50);
  fill(255); noStroke(); textSize(30);
  text(`Total Score: ${score}`, width/2, height/2 + 30);
  textSize(24); text("ç”»é¢ã‚¿ãƒƒãƒ—ã§ãƒªãƒˆãƒ©ã‚¤", width/2, height/2 + 100);
}

function playGame() {
  let progress = constrain(map(currentAngle, angleClosed, angleOpen, 0, 1), 0, 1);
  currentCm = progress * 10.0; 

  let batX = map(progress, 0, 1, batRangeStart, batRangeEnd);
  let batY = map(progress, 0, 1, height - 100, height - 250);
  
  let isBatActive = (progress >= 0.25); 
  let batBaseLen = 140;
  let batLen = max(batBaseLen - (level - 1) * 10, 50); 

  push();
  translate(batX, batY);
  
  // ãƒãƒƒãƒˆã®å›è»¢æ–¹å‘ï¼ˆå·¦å³ã§é€†ï¼‰
  if (isRightHand) {
    rotate(map(progress, 0, 1, PI/4, -PI/4));
  } else {
    rotate(map(progress, 0, 1, -PI/4, PI/4));
  }
  
  if (isBatActive) {
    fill(progress > 0.8 ? color(255,50,50) : color(255,255,0)); stroke(0);
  } else {
    fill(100, 150); noStroke();
  }
  rect(-15, 0, 30, batLen, 10);
  if (!isBatActive) {
    fill(255); textSize(20); textAlign(CENTER); noStroke();
    text("WAIT", 0, -20);
  }
  pop();

  if (balls.length === 0 && frameCount % 60 === 0) {
    balls.push(new Ball(level));
  }

  for (let i = balls.length - 1; i >= 0; i--) {
    let b = balls[i];
    b.update(); b.display();
    
    // ã‚¬ã‚¤ãƒ‰å†…åˆ¤å®š
    let distToGuide = dist(b.x, b.y, guidePositionX, guidePositionY);
    let inZone = (distToGuide < 100); 

    let hitThreshold = 300; 
    
    if (isBatActive && !b.isHit && inZone && dist(b.x, b.y, batX, batY) < hitThreshold) {
      playHitSound();
      b.hit(progress); 
    }

    if (b.isHit) {
      for (let p of panels) {
        if (p.active && b.x > p.x && b.x < p.x + p.w && b.y > p.y && b.y < p.y + p.h) {
          p.active = false; score++; 
          
          combo++;
          if (combo > 40) showMessage("æœ€é«˜ã‹ã‚ˆã£â—ï¸", color(255, 50, 50));
          else if (combo > 30) showMessage("å¤§è°·ç¿”å¹³ã‹ã‚ˆâ—ï¸ğŸ‘ï¸", color(255, 0, 255));
          else if (combo > 20) showMessage("æœ€é«˜ã«ã‚¤ã‚¤ã˜ã‚ƒã‚“ï¼ğŸ‘ï¸", color(255, 100, 0));
          else if (combo > 10) showMessage("ã‚ã£ã¡ã‚ƒã‚¤ã‚¤ã˜ã‚ƒã‚“â—ï¸ğŸ‘ï¸", color(255, 255, 0));
          else showMessage("ã‚¤ã‚¤ã˜ã‚ƒã‚“ï¼ğŸ‘ï¸", color(255, 255, 0));

          checkLevelUp();
          balls.splice(i, 1); break;
        }
      }
    }

    if (b.y > height + 100 || b.y < -300 || b.x < -200 || b.x > width + 200) {
      if (!b.isHit) {
        lives--; 
        combo = 0; 
        showMessage("MISS!", color(100, 100, 255));
        if (lives <= 0) gameState = 5;
      }
      balls.splice(i, 1);
    }
  }
  drawGameUI(progress);
}

function checkLevelUp() {
  if (score > 0 && score % 10 === 0) {
    level++; showMessage(`LEVEL UP! Lv.${level}`, color(0, 255, 0));
  }
}

function playHitSound() {
  if (hitSoundEnv && hitSoundOsc) {
    hitSoundOsc.freq(800); hitSoundEnv.play();
    setTimeout(() => { hitSoundOsc.freq(1200); }, 30);
  }
}

function drawGameUI(progress) {
  fill(255); stroke(0); strokeWeight(4);
  textAlign(RIGHT, TOP); textSize(32); 
  text(`æ‰“ç‚¹: ${score}`, width - 20, 20); text(`Lv.${level}`, width - 20, 60);

  if (combo > 1) {
    fill(255, 200, 0); textSize(40);
    text(`${combo} COMBO!`, width - 20, 110);
  }

  textAlign(LEFT, TOP); fill(255, 50, 50); textSize(32);
  let hearts = "â¤ï¸".repeat(lives); let empty = "ğŸ¤".repeat(maxLives - lives);
  text(`Life: ${hearts}${empty}`, 20, 20);

  let uiW = 220; 
  let uiX = width / 2 - uiW / 2; // ä¸­å¤®
  let uiY = 10; 
  
  fill(0, 150); noStroke(); rect(uiX, uiY, uiW, 80, 10);
  
  fill(255); textAlign(CENTER, TOP); textSize(16); noStroke();
  text("ç¾åœ¨ã®å¯å‹•åŸŸ", uiX + uiW/2, uiY + 5);
  
  textSize(30); textStyle(BOLD);
  text(currentCm.toFixed(1) + " cm", uiX + uiW/2, uiY + 30);

  let barX = uiX + 10; let barY = uiY + 70; let barW = 200;
  stroke(255); strokeWeight(2); noFill(); rect(barX, barY, barW, 10); 
  noStroke(); fill(progress > 0.8 ? color(255,50,50) : color(255,255,0));
  rect(barX, barY, map(progress, 0, 1, 0, barW), 10); 

  if (messageTimer > 0) {
    textAlign(CENTER); fill(messageColor); stroke(0); strokeWeight(4);
    textSize(60); text(message, width/2, height/3); messageTimer--;
  }
}

function showMessage(t, c) { message = t; messageColor = c; messageTimer = 60; }

class Ball {
  constructor(currentLevel) {
    this.startX = 0; this.startY = height * 0.85; 
    
    // å·¦å³åè»¢: å·¦æ‰‹ãƒ¢ãƒ¼ãƒ‰ãªã‚‰ãƒœãƒ¼ãƒ«ã¯å³ä¸‹ã‹ã‚‰å‡ºã‚‹ã€ã¨è¦‹ã›ã‹ã‘ã¦
    // å®Ÿéš›ã¯ã€ŒæŠ•ã’ã‚‹ä½ç½®ã€ã§ã¯ãªãã€Œé£›ã‚“ã§ãã‚‹æ–¹å‘ã€ãŒé‡è¦ã€‚
    // ã‚·ãƒ³ãƒ—ãƒ«ã«ç”»é¢ä¸‹ä¸­å¤®ä»˜è¿‘ã‹ã‚‰ã€ã‚¬ã‚¤ãƒ‰ã«å‘ã‹ã£ã¦é£›ã¶ã‚ˆã†ã«ã™ã‚‹ã€‚
    // å³æ‰‹ãƒ¢ãƒ¼ãƒ‰: ãƒ‘ãƒãƒ«(å·¦)ã¸æ‰“ã¡è¿”ã™ -> ãƒœãƒ¼ãƒ«ã¯å³å¯„ã‚Šã‹ã‚‰æ¥ã‚‹ã¨æ‰“ã¡ã‚„ã™ã„ï¼Ÿ
    // ã„ã‚„ã€æ­£é¢ã‹ã‚‰ã®æ–¹ãŒè‡ªç„¶ã€‚startXã¯ä¸­å¤®ã§OKã€‚
    
    this.x = width / 2; 
    this.y = height; 

    let baseSpeed = 6 + (currentLevel - 1) * 1.5; 
    let speed = random(baseSpeed, baseSpeed + 2); 

    // ä¸¸ã‚¬ã‚¤ãƒ‰ã«å‘ã‹ã£ã¦é£›ã¶
    let homeBaseCenterX = guidePositionX;
    let targetX = random(homeBaseCenterX - 50, homeBaseCenterX + 50);
    let targetY = guidePositionY - 50; 

    let dirX = targetX - this.x; let dirY = targetY - this.y;
    let distLen = sqrt(dirX*dirX + dirY*dirY);
    
    this.vx = (dirX / distLen) * speed; 
    this.vy = (dirY / distLen) * speed;
    this.isHit = false; this.ballColor = color(255);
  }
  update() { this.x += this.vx; this.y += this.vy; if (this.isHit) this.vy += 0.2; }
  display() { fill(this.ballColor); stroke(0); strokeWeight(1); ellipse(this.x, this.y, 30); }
  
  hit(progress) {
    this.isHit = true; this.ballColor = color(255, 255, 0);
    
    // å·¦å³ã§ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¨ãƒªã‚¢ã®æ–¹å‘ãŒå¤‰ã‚ã‚‹
    let areaW = 3 * panels[0].w + 30; 
    let areaLeft, areaRight;

    if (isRightHand) {
      // å³æ‰‹: ãƒ‘ãƒãƒ«ã¯å·¦å´
      areaLeft = panelStartX; 
      areaRight = panelStartX + areaW;
    } else {
      // å·¦æ‰‹: ãƒ‘ãƒãƒ«ã¯å³å´
      areaLeft = panelStartX;
      areaRight = panelStartX + areaW;
    }
    
    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆXè¨ˆç®—ï¼ˆå·¦å³å…±é€šã®ãƒ­ã‚¸ãƒƒã‚¯ã§ã„ã‘ã‚‹ã‹ç¢ºèªï¼‰
    // å³æ‰‹(RightHand=true): progresså°(å³å´ãƒ»é…ã„) -> Right, progresså¤§(å·¦å´ãƒ»æ—©ã„) -> Left
    // å·¦æ‰‹(RightHand=false): progresså°(å·¦å´ãƒ»é…ã„) -> Left, progresså¤§(å³å´ãƒ»æ—©ã„) -> Right
    let targetX;
    if (isRightHand) {
        targetX = map(progress, 0.3, 0.9, areaRight, areaLeft);
    } else {
        // å·¦æ‰‹ã¯é–‹ãã¨å³ã¸æŒ¯ã‚‹
        targetX = map(progress, 0.3, 0.9, areaLeft, areaRight);
    }

    let areaTop = panels[0].y; 
    let areaBottom = panels[8].y + panels[8].h;
    
    let targetY = map(constrain(progress, 0.3, 0.6), 0.3, 0.6, areaBottom, areaTop - 30); 

    let dx = targetX - this.x; let dy = targetY - this.y;
    let distLen = sqrt(dx*dx + dy*dy);
    let flySpeed = 30; 
    this.vx = (dx / distLen) * flySpeed; this.vy = (dy / distLen) * flySpeed;
  }
}
</script>
</body>
</html>
